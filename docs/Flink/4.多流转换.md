# 多流转换

多流转换可以分为**分流**和**合流**两大类：

- 分流：通过侧输出流实现
- 合流：通过 `union()`、`connect()`、`join()`、`coGroup()` 实现

## 分流

![](https://raw.githubusercontent.com/LIMUXUALE0927/image/main/img/202410031703060.png)

处理函数本身可以认为是一个转换算子，它的输出类型是单一的，处理之后得到的仍然是一个 DataStream。而侧输出流则不受限制，可以任意自定义输出数据，它们就像从“主流”上分叉出的“支流”。

利用侧输出流可以很方便地实现分流操作，而且得到的多条 DataStream 类型可以不同，这能给我们的应用带来了极大的便利。使用时只需要调用上下文 ctx 的 `.output()` 方法，就可以输出任意类型的数据了。而侧输出流的标记和提取，都离不开一个“输出标签”（OutputTag），它就相当于 `split()` 分流时的“戳”，指定了侧输出流的 id 和类型。

```java
DataStream<Integer> input = ...;

final OutputTag<String> outputTag = new OutputTag<String>("side-output"){};

SingleOutputStreamOperator<Integer> mainDataStream = input
  .process(new ProcessFunction<Integer, Integer>() {

      @Override
      public void processElement(
          Integer value,
          Context ctx,
          Collector<Integer> out) throws Exception {
        // emit data to regular output
        out.collect(value);

        // emit data to side output
        ctx.output(outputTag, "sideout-" + String.valueOf(value));
      }
    });
```

```java
final OutputTag<String> outputTag = new OutputTag<String>("side-output"){};

SingleOutputStreamOperator<Integer> mainDataStream = ...;

DataStream<String> sideOutputStream = mainDataStream.getSideOutput(outputTag);
```

---

## 合流

### Union

最简单的合流操作，就是直接将多条流合在一起，叫作流的「**联合**」（union）。联合操作要求必须流中的数据类型必须相同，合并之后的新流会包括所有流中的元素，数据类型不变。

![](https://raw.githubusercontent.com/LIMUXUALE0927/image/main/img/202410031712765.png)

```java
stream1.union(stream2, stream3, ...)
```

这里需要考虑一个问题：在事件时间语义下，水位线是时间的进度标志，不同的流中可能水位线的进展快慢完全不同，如果它们合并在一起，水位线又该以哪个为准呢？

还以要考虑水位线的本质含义，是「之前的所有数据已经到齐了」。所以对于合流之后的水位线，也是要以最小的那个为准，这样才可以保证所有流都不会再传来之前的数据。即：**多流合并时处理的时效性是以最慢的那个流为准的**。

---

### Connect

流的联合虽然简单，不过**受限于数据类型不能改变**，灵活性大打折扣，所以实际应用较少出现。除了联合（union），Flink 还提供了另外一种方便的合流操作：「**连接**」（connect）。

为了处理更加灵活，连接操作允许流的数据类型不同。但我们知道一个 DataStream 中的数据只能有唯一的类型，所以连接得到的并不是 DataStream，而是一个**「连接流」（ConnectedStreams）**。连接流可以看成是两条流形式上的“统一”，被放在了一个同一个流中，事实上内部仍保持各自的数据形式不变，彼此之间是相互独立的。

要想得到新的 DataStream，还需要进一步定义一个**「同处理」（co-process）**转换操作，用来说明对于不同来源、不同类型的数据，怎样分别进行处理转换、得到统一的输出类型。

![](https://raw.githubusercontent.com/LIMUXUALE0927/image/main/img/202410031716021.png)

```java
DataStream<Integer> stream1 = env.fromElements(1,2,3);
DataStream<Long> stream2 = env.fromElements(1L,2L,3L);
ConnectedStreams<Integer, Long> connectedStreams = stream1.connect(stream2);
SingleOutputStreamOperator<String> result = connectedStreams.map(new
    CoMapFunction<Integer, Long, String>() {
        @Override
        public String map1(Integer value) {
            return "Integer: " + value;
        }
        @Override
        public String map2(Long value) {
            return "Long: " + value;
        }
    });
result.print();
env.execute();
```

---

### Join

对于两条流的合并，很多情况我们并不是简单地将所有数据放在一起，而是希望根据某个字段的值将它们联结起来，“配对”去做处理。

#### Window join

通用调用形式如下：

```java
stream1.join(stream2)
    .where(<KeySelector>)
    .equalTo(<KeySelector>)
    .window(<WindowAssigner>)
    .apply(<JoinFunction>)
```

解释：

- `.where()` 的参数是键选择器（KeySelector），用来指定第一条流中的 key
- `.equalTo()` 传入的 KeySelector 则指定了第二条流中的 key
- 两者相同的元素，如果在同一窗口中，就可以匹配起来，并通过一个 JoinFunction 进行处理了
- `.window()` 传入的就是窗口分配器，可以使用：滚动窗口、滑动窗口和会话窗口
