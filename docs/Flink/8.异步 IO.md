# 异步 I/O

## 同步 I/O 处理导致作业低吞吐

I/O 操作常用且简单，我们直接在 Map、FlatMap 这类算子里访问外部的数据库就可以，但是当吞吐量逐渐变大时，问题就浮现出来了，原因在于对外部数据库或 K-V 引擎的 I/O 访问操作是一个非常耗时的过程。

![](https://raw.githubusercontent.com/LIMUXUALE0927/image/main/img/202502102051668.png)

以 Map 算子为例，在不访问外部存储的情况下，Map 算子的一个 SubTask 峰值吞吐量大约为 10000QPS（每 0.1ms 处理一条数据）。如果 Map 算子访问数据库，就需要经过网络请求，那么 Map 算子的一个 SubTask 从接收一条数据，到通过网络请求访问数据库并获取数据（一般需要花费 10ms），再到处理数据（0.1ms），所花的时间就会变为 10.1ms，这时 Map 算子的一个 SubTask 峰值吞吐量就变为 100QPS（10ms 处理一条数据）了。不访问外部存储和访问外部存储相比，Map 算子一个 SubTask 的峰值吞吐量下降了 100 倍。

上述 Map 算子访问外部存储引擎的处理过程被称作同步 I/O 处理。如图所示，同步 I/O 处理吞吐量低的原因在于每处理 1 条数据，实际上只有 0.1ms 用于处理数据，剩下的 10ms 都在等待数据库返回结果，这 10ms 的时间里什么也不能做，资源被白白浪费了。

![](https://raw.githubusercontent.com/LIMUXUALE0927/image/main/img/202502102052140.png)

---

## 同步 I/O 处理低吞吐的 4 种解决方案

### 方案一：提高 Map 算子的并行度

通过提高 Map 算子并行度，增加 SubTask 的个数来增加吞吐。举例来说，当 Map 算子的并行度为 10 时，Map 算子的每个 SubTask 的峰值吞吐为 100QPS，那么整个 Map 算子的峰值吞吐为 1000QPS。如果这时数据源的峰值为 10000QPS，那么就可以计算出要将 Map 算子的并行度最少提高到 100 才能处理 10000QPS 的数据。

提高算子并行度是解决低吞吐问题最简单的一种方案，该方案的缺点在于算子并行度越大，我们需要为这个 Flink 作业分配的资源就越多，需要部署更多的 TaskManager，分配更多的 TaskSlot，而同步 I/O 处理不是 CPU 密集型的工作，我们分配的这些资源很多都是闲置状态，存在资源浪费。

### 方案二：使用使用本地缓存来减少 I/O 请求

大多数场景中，I/O 处理访问的外部维表中的数据变化频率很低，比如用户画像数据，因此第一次访问之后，就可以将结果缓存在 SubTask 的本地缓存中，这样可以减少 I/O 请求。

此外，我们还可以将 I/O 处理的请求参数作为 KeyBy 操作的 key，将相同 key 的数据发送到 I/O 处理算子的同一个 SubTask 中，从而提高本地缓存的命中率。

### 方案三：批量访问外部存储

对外部数据库进行批量访问可以均摊请求结果的返回时间，提高吞吐量。举例来说，假如我们访问的数据库是 Redis，那么可以在 Flink 作业中实现每攒够 20 条数据，使用 Redis 提供的工具 RedisPipeline 批量访问一次 Redis，每次访问只需要花费 10ms，在这 10ms 内就可以处理 20 条数据。相比原本一个 SubTask 每 10ms 只能处理 1 条数据，峰值吞吐量提高了 20 倍。

### 方案四：使用异步 I/O 处理

在同步 I/O 处理的过程中，每 10ms 只能发送并接收 1 个数据库请求，当我们将这个过程转变为异步 I/O 处理后，第一个数据库请求发出之后，算子不需要一直等待结果返回，可以继续处理后续的数据，接着对数据库发出请求。只有当数据库请求返回之后，算子才接着处理数据，产出结果。原本只能用于等待的 10ms 时间被充分利用了起来，从而提升了 SubTask 的峰值吞吐量。

![](https://raw.githubusercontent.com/LIMUXUALE0927/image/main/img/202502102057806.png)

---

## 对于异步 I/O 操作的需求

在与外部系统交互（用数据库中的数据扩充流数据）的时候，需要考虑与外部系统的通信延迟对整个流处理应用的影响。

简单地访问外部数据库的数据，比如使用 MapFunction，通常意味着同步交互：MapFunction 向数据库发送一个请求然后一直等待，直到收到响应。在许多情况下，等待占据了函数运行的大部分时间。

与数据库异步交互是指一个并行函数实例可以并发地处理多个请求和接收多个响应。这样，函数在等待的时间可以发送其他请求和接收其他响应。至少，等待的时间可以被多个请求摊分。大多数情况下，异步交互可以大幅度提高流处理的吞吐量。

![](https://raw.githubusercontent.com/LIMUXUALE0927/image/main/img/202412030741932.png)

!!! note

    仅仅提高 MapFunction 的并行度（parallelism）在有些情况下也可以提升吞吐量，但是这样做通常会导致非常高的资源消耗：更多的并行 MapFunction 实例意味着更多的 Task、更多的线程、更多的 Flink 内部网络连接、 更多的与数据库的网络连接、更多的缓冲和更多程序内部协调的开销。

https://nightlies.apache.org/flink/flink-docs-release-1.20/zh/docs/dev/datastream/operators/asyncio/
