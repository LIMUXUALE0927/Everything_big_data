# 算法复习

## 搜索算法

![](https://raw.githubusercontent.com/MXJULY/image/main/img/202312060511256.png)

|              | 线性搜索 | 二分查找           | 树查找             | 哈希查找        |
| ------------ | -------- | ------------------ | ------------------ | --------------- |
| 查找元素     | $O(n)$   | $O(\log n)$        | $O(\log n)$        | $O(1)$          |
| 插入元素     | $O(1)$   | $O(n)$             | $O(\log n)$        | $O(1)$          |
| 删除元素     | $O(n)$   | $O(n)$             | $O(\log n)$        | $O(1)$          |
| 额外空间     | $O(1)$   | $O(1)$             | $O(n)$             | $O(n)$          |
| 数据预处理   | /        | 排序 $O(n \log n)$ | 建树 $O(n \log n)$ | 建哈希表 $O(n)$ |
| 数据是否有序 | 无序     | 有序               | 有序               | 无序            |

### 二分查找

=== "经典二分"

    ```java
    class Solution {
        public int search(int[] nums, int target) {
            if (target < nums[0] || target > nums[nums.length - 1]) {
                return -1;
            }

            int left = 0, right = nums.length - 1;
            while (left <= right) {
                int mid = left + (right - left) / 2;
                if (nums[mid] == target)
                    return mid;
                else if (nums[mid] < target)
                    left = mid + 1;
                else if (nums[mid] > target)
                    right = mid - 1;
            }
            return -1;
        }
    }
    ```

=== "后继型二分"

    查找第一个 `>=target` 的数的下标，不存在则返回 n。（后继型）

    ```java
    class Solution {
        public int search(int[] nums, int target) {
            // nums.length是保护节点，由于往下取整永远不会被访问到，如果最后返回nums.length则表示无解
            int left = 0, right = nums.length;
            while (left < right) {
                int mid = left + (right - left) / 2;
                if (nums[mid] >= target) { // 条件被满足的一侧应该被包含
                    right = mid;
                } else {
                    left = mid + 1; // 条件不满足的一侧直接去掉
                }
            }
            return right;
        }
    }

    ```

=== "前驱型二分"

    查找最后一个 `<= target` 的数的下标，不存在则返回 -1。（前驱型）

    ```java
    class Solution {
        public int search(int[] nums, int target) {
            // -1是保护节点，由于向上取整永远不会被访问到，如果最后返回-1则表示无解
            int left = -1, right = nums.length - 1;
            while (left < right) {
                int mid = left + (right - left + 1) / 2; // 向上取整，避免陷入死循环
                if (nums[mid] <= target) { // 条件被满足的一侧应该被包含
                    left = mid;
                } else {
                    right = mid - 1; // 条件不满足的一侧直接去掉
                }
            }
            return right;
        }
    }
    ```

---

## 排序算法

### 选择排序

[选择排序](https://www.hello-algo.com/chapter_sorting/selection_sort/)

「选择排序 selection sort」的工作原理非常简单：开启一个循环，每轮从未排序区间选择最小的元素，将其放到已排序区间的末尾。

设数组的长度为 $n$ ，选择排序的算法流程如下图所示。

1. 初始状态下，所有元素未排序，即未排序（索引）区间为 $[0, n-1]$ 。
2. 选取区间 $[0, n-1]$ 中的最小元素，将其与索引 $0$ 处的元素交换。完成后，数组前 1 个元素已排序。
3. 选取区间 $[1, n-1]$ 中的最小元素，将其与索引 $1$ 处的元素交换。完成后，数组前 2 个元素已排序。
4. 以此类推。经过 $n - 1$ 轮选择与交换后，数组前 $n - 1$ 个元素已排序。
5. 仅剩的一个元素必定是最大元素，无须排序，因此数组排序完成。

```python
def selection_sort(nums: list[int]):
    n = len(nums)
    # 外循环：未排序区间为 [i, n-1]
    for i in range(n - 1):
        min_idx = i
        for j in range(i + 1, n):
            if nums[j] < nums[min_idx]:
                min_idx = j
        nums[i], nums[min_idx] = nums[min_idx], nums[i]
```

---

### 冒泡排序
