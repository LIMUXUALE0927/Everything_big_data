# 一些好题

!!! tip "[53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/)"

    给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

=== "线性 DP"

    ```python
    class Solution:
        def maxSubArray(self, nums: List[int]) -> int:
            n = len(nums)
            f = [-inf] * n
            for i in range(n):
                f[i] = max(nums[i], f[i - 1] + nums[i] if i > 0 else nums[i])
            return max(f)
    ```

=== "分治"

    使用分治可以求得任意 `[l...r]` 区间的最大子数组和：事实上是线段树的 pushUp 操作

    ```java
    class Solution {
        static class Node {
            int lmax, rmax, tmax, sum;
            Node(int lmax, int rmax, int tmax, int sum) {
                this.lmax = lmax;
                this.rmax = rmax;
                this.tmax = tmax;
                this.sum = sum;
            }
        }

        public int maxSubArray(int[] nums) {
            return query(nums, 0, nums.length - 1).tmax;
        }

        private Node query(int[] a, int l, int r) {
            if (l == r) {
                return new Node(a[l], a[l], a[l], a[l]);
            }
            int mid = l + r >> 1;
            Node left = query(a, l, mid);
            Node right = query(a, mid + 1, r);
            return pushUp(left, right);
        }

        private Node pushUp(Node left, Node right) {
            int sum = left.sum + right.sum;
            int lmax = Math.max(left.lmax, left.sum + right.lmax);
            int rmax = Math.max(right.rmax, right.sum + left.rmax);
            int tmax = Math.max(Math.max(left.tmax, right.tmax), left.rmax + right.lmax);
            return new Node(lmax, rmax, tmax, sum);
        }
    }
    ```

=== "前缀和"

    `最大子数组和 = max(当前前缀和 - 前面最小的前缀和)`

    ```python
    class Solution:
        def maxSubArray(self, nums: List[int]) -> int:
            n = len(nums)
            presum = 0
            min_presum = inf
            ans = -inf
            for x in nums:
                min_presum = min(min_presum, presum)
                presum += x
                ans = max(ans, presum - min_presum)
            return ans
    ```
