将问题规模减小的方式有很多种，一些典型的减小方式是动态规划分类的依据，例如线性，区间，树形等。线性动态规划缩小问题规模的思路通常有：

- 每次减少一半：每次将问题规模减少一半
- 每次减少一个：记 f(n) 为以第 n 个数结尾的最长子序列，每次减少一个，将原问题分为 f(n−1), f(n−2), ..., f(1)，共 n−1 个子问题。

## 单串问题

![](https://raw.githubusercontent.com/MXJULY/image/main/img/202309150228264.png)

==1.依赖比 i 小的 O(1) 个子问题==

[53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/)

> 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

=== "线性 DP"

    ```python
    class Solution:
        def maxSubArray(self, nums: List[int]) -> int:
            n = len(nums)
            f = [-inf] * n
            for i in range(n):
                f[i] = max(nums[i], f[i - 1] + nums[i] if i > 0 else nums[i])
            return max(f)
    ```

=== "分治"

    使用分治可以求得任意 `[l...r]` 区间的最大子数组和：事实上是线段树的 pushUp 操作

    ```java
    class Solution {
        static class Node {
            int lmax, rmax, tmax, sum;
            Node(int lmax, int rmax, int tmax, int sum) {
                this.lmax = lmax;
                this.rmax = rmax;
                this.tmax = tmax;
                this.sum = sum;
            }
        }

        public int maxSubArray(int[] nums) {
            return query(nums, 0, nums.length - 1).tmax;
        }

        private Node query(int[] a, int l, int r) {
            if (l == r) {
                return new Node(a[l], a[l], a[l], a[l]);
            }
            int mid = l + r >> 1;
            Node left = query(a, l, mid);
            Node right = query(a, mid + 1, r);
            return pushUp(left, right);
        }

        private Node pushUp(Node left, Node right) {
            int sum = left.sum + right.sum;
            int lmax = Math.max(left.lmax, left.sum + right.lmax);
            int rmax = Math.max(right.rmax, right.sum + left.rmax);
            int tmax = Math.max(Math.max(left.tmax, right.tmax), left.rmax + right.lmax);
            return new Node(lmax, rmax, tmax, sum);
        }
    }
    ```

==2.依赖比 i 小的 O(n) 个子问题==

[300. 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/description/)

> 给定一个无序的整数数组，找到其中最长上升子序列的长度。

```python
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        n = len(nums)
        f = [1] * n
        for i in range(n):
            for j in range(i):
                if nums[i] > nums[j]:
                    f[i] = max(f[i], f[j] + 1)
        return max(f)
```

### LIS 问题

#### [300. 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/description/)

=== "线性 DP"

    ```python
    class Solution:
        def lengthOfLIS(self, nums: List[int]) -> int:
            n = len(nums)
            f = [1] * n
            for i in range(n):
                for j in range(i):
                    if nums[i] > nums[j]:
                        f[i] = max(f[i], f[j] + 1)
            return max(f)
    ```

    时间复杂度：$O(n^2)$

=== ":fire: 贪心 + 二分"

    考虑一个简单的贪心，如果我们要使上升子序列尽可能的长，则我们需要让序列上升得尽可能慢，因此我们希望每次在上升子序列最后加上的那个数尽可能的小。
    基于上面的贪心思路，我们维护一个数组 `d[i]` ，表示长度为 `(i+1)` 的最长上升子序列的末尾元素的最小值，用 `len(d)` 记录目前最长上升子序列的长度。同时我们注意到 `d[i]` 是关于 `i` 单调递增的。

    ```python
    class Solution:
        def lengthOfLIS(self, nums: List[int]) -> int:
            n = len(nums)
            g = []
            for x in nums:
                j = bisect_left(g, x)
                if j == len(g):
                    g.append(x)
                else:
                    g[j] = x
            return len(g)
    ```

    时间复杂度：$O(nlogn)$

??? note "关于贪心 + 二分的解释"

    思路源自于纸牌游戏 [patience game](https://www.youtube.com/watch?v=22s1xxRvy28)

    ![](https://raw.githubusercontent.com/MXJULY/image/main/img/202309150241012.png)

    > 给你一排扑克牌，我们像遍历数组那样从左到右一张一张处理这些扑克牌，最终要把这些牌分成若干堆。只能把点数小的牌压到点数比它大的牌上；如果当前牌点数较大没有可以放置的堆，则新建一个堆，把这张牌放进去；如果当前牌有多个堆可供选择，则选择最左边的那一堆放置，这样可以保证牌堆顶的牌有序（2, 4, 7, 8, Q）。

    ![](https://raw.githubusercontent.com/MXJULY/image/main/img/202309150242508.png)

    > [3, 5, 7, 8, Q] 就是 LIS

---

#### :star: [673. 最长递增子序列的个数](https://leetcode.cn/problems/number-of-longest-increasing-subsequence/description/)

以 `nums[i]` 为结尾的字符串，最长递增子序列的个数为 `count[i]`。

那么在 `nums[i]` > `nums[j]` 前提下，如果在 `[0, i-1]` 的范围内，找到了 j，使得 `dp[j] + 1 > dp[i]`，说明找到了一个更长的递增子序列。

那么以 j 为结尾的子串的最长递增子序列的个数，就是最新的以 i 为结尾的子串的最长递增子序列的个数，即：`count[i] = count[j]`。

在 `nums[i] > nums[j]` 前提下，如果在 `[0, i-1]` 的范围内，找到了 j，使得 `dp[j] + 1 == dp[i]`，说明找到了两个相同长度的递增子序列。

那么以 i 为结尾的子串的最长递增子序列的个数 就应该加上以 j 为结尾的子串的最长递增子序列的个数，即：`count[i] += count[j]` 。

```python
class Solution:
    def findNumberOfLIS(self, nums: List[int]) -> int:
        n = len(nums)
        f = [1] * n
        # 定义g[i]为以nums[i]结尾的最长上升子序列的方案数
        g = [1] * n
        max_len = 1
        for i in range(n):
            for j in range(i):
                if nums[i] > nums[j]:
                    # 意味着我们第一次找到以nums[i]结尾的LIS
                    if f[i] < f[j] + 1:
                        f[i] = f[j] + 1
                        g[i] = g[j]
                    # 意味着我们不是第一次找到以nums[i]结尾、长度为f[i]的LIS了，并找到了一个新的符合条件的前驱
                    elif f[i] == f[j] + 1:
                        g[i] += g[j]
            max_len = max(max_len, f[i])
        ans = 0
        for i in range(n):
            if f[i] == max_len:
                ans += g[i]
        return ans
```

---

#### :fire: [354. 俄罗斯套娃信封问题](https://leetcode.cn/problems/russian-doll-envelopes/description/)

=== "暴力解法"

    暴力解法时间复杂度为：$O(n^2)$，因此会超时。

    ```python
    class Solution:
        def maxEnvelopes(self, envelopes: List[List[int]]) -> int:
            envelopes.sort()
            n = len(envelopes)
            f = [1] * n
            for i in range(n):
                for j in range(i):
                    if envelopes[i][0] > envelopes[j][0] and envelopes[i][1] > envelopes[j][1]:
                        f[i] = max(f[i], f[j] + 1)
            return max(f)
    ```

=== "排序 + 二分"

    思路同 LIS 问题的贪心 + 二分解法。这里将高度逆序排序的意义是，对于相同宽度的信封，多个高度我们只会取一个，同时由于二分，我们能同时考虑所有的高度。`g[i]`: 长度为 `(i+1)` 的 LIS 的最小「信封高度」。思路源自于纸牌游戏 patience game。

    ```python
    class Solution:
        def maxEnvelopes(self, envelopes: List[List[int]]) -> int:
            n = len(envelopes)
            envelopes.sort(key=lambda x: (x[0], -x[1]))
            # g[i]: 长度为 (i+1) 的 LIS 的最小「信封高度」
            g = []
            size = 0
            for w, h in envelopes:
                if not g or h > g[-1]:
                    g.append(h)
                    size += 1
                else:
                    idx = bisect_left(g, h)
                    g[idx] = h
            return size
    ```

---

### 最大子数组和问题

[53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/description/)

=== "线性 DP"

    ```python
    class Solution:
        def maxSubArray(self, nums: List[int]) -> int:
            n = len(nums)
            f = [-inf] * n
            for i in range(n):
                f[i] = max(nums[i], f[i - 1] + nums[i] if i > 0 else nums[i])
            return max(f)
    ```

=== "分治解法"

    ```java
    class Solution {
        static class Node {
            int lmax, rmax, tmax, sum;
            Node(int lmax, int rmax, int tmax, int sum) {
                this.lmax = lmax;
                this.rmax = rmax;
                this.tmax = tmax;
                this.sum = sum;
            }
        }

        public int maxSubArray(int[] nums) {
            return query(nums, 0, nums.length - 1).tmax;
        }

        private Node query(int[] a, int l, int r) {
            if (l == r) {
                return new Node(a[l], a[l], a[l], a[l]);
            }
            int mid = l + r >> 1;
            Node left = query(a, l, mid);
            Node right = query(a, mid + 1, r);
            return pushUp(left, right);
        }

        private Node pushUp(Node left, Node right) {
            int sum = left.sum + right.sum;
            int lmax = Math.max(left.lmax, left.sum + right.lmax);
            int rmax = Math.max(right.rmax, right.sum + left.rmax);
            int tmax = Math.max(Math.max(left.tmax, right.tmax), left.rmax + right.lmax);
            return new Node(lmax, rmax, tmax, sum);
        }
    }
    ```

---

#### [152. 乘积最大子数组](https://leetcode.cn/problems/maximum-product-subarray/description/)

整体思路和 53 题类似，对于每一个 `nums[i]` 考虑 2 种情况：

- 接在 `f[i-1]` 后面
- 不接在 `f[i-1]` 后面

由于 `nums[i]` 有可能是负数，因此除了维护一个 `pre_max` 之外还要额外维护一个 `pre_min` ，用于处理负数的情况。

```python
class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        n = len(nums)
        pre_max = pre_min = nums[0]
        ans = nums[0]
        for i in range(1, n):
            cur_max = max(pre_max * nums[i], pre_min * nums[i], nums[i])
            cur_min = min(pre_max * nums[i], pre_min * nums[i], nums[i])
            ans = max(ans, cur_max)
            pre_max = cur_max
            pre_min = cur_min
        return ans
```

---

#### [918. 环形子数组的最大和](https://leetcode.cn/problems/maximum-sum-circular-subarray/description/)

```python
class Solution:
    def maxSubarraySumCircular(self, nums: List[int]) -> int:
        n = len(nums)
        fmax = [-inf] * n
        fmin = [inf] * n
        fmax[0] = fmin[0] = nums[0]
        mx = mn = nums[0]
        for i in range(1, n):
            fmax[i] = max(nums[i], fmax[i - 1] + nums[i])
            mx = max(mx, fmax[i])
            fmin[i] = min(nums[i], fmin[i - 1] + nums[i])
            mn = min(mn, fmin[i])
        # 注意全是负数的情况
        if mx < 0:
            return mx
        return max(mx, sum(nums) - mn)
```

#### :star: [面试题 17.24. 最大子矩阵](https://leetcode.cn/problems/max-submatrix-lcci/description/)

```python
class Solution:
    def getMaxMatrix(self, matrix):
        m, n = len(matrix), len(matrix[0])
        # 记录当前i~j行组成大矩阵的每一列的和，将二维转化为一维
        b = [0] * n
        max_sum = -inf
        ans = [0, 0, 0, 0]
        # 记录左上角
        start = [0, 0]
        for i in range(m):
            b = [0] * n
            for j in range(i, m):
                sum_ = 0
                for k in range(n):
                    b[k] += matrix[j][k]
                    if sum_ > 0:
                        sum_ += b[k]
                    else:
                        sum_ = b[k]
                        start = [i, k]
                    if sum_ > max_sum:
                        max_sum = sum_
                        ans = [start[0], start[1], j, k]
        return ans
```

#### :fire: [363. 矩形区域不超过 K 的最大数值和](https://leetcode.cn/problems/max-sum-of-rectangle-no-larger-than-k/description/)

=== "二维前缀和 + 枚举"

=== "有序集合 + 二分"

    [题解](https://leetcode.cn/problems/max-sum-of-rectangle-no-larger-than-k/solutions/734547/gong-shui-san-xie-you-hua-mei-ju-de-ji-b-dh8s/)

    ```java
    class Solution {
        public int maxSumSubmatrix(int[][] matrix, int k) {
            int ans = Integer.MIN_VALUE;
            int m = matrix.length, n = matrix[0].length;
            for (int i = 0; i < m; i++) {  // 枚举上边界
                int[] sum = new int[n];
                for (int j = i; j < m; j++) {  // 枚举下边界
                    for (int c = 0; c < n; c++) {
                        sum[c] += matrix[j][c];
                    }
                    TreeSet<Integer> set = new TreeSet<>();
                    set.add(0);
                    int s = 0;
                    for (int v : sum) {
                        s += v;
                        Integer ceil = set.ceiling(s - k);
                        if (ceil != null) {
                            ans = Math.max(ans, s - ceil);
                        }
                        set.add(s);
                    }
                }
            }
            return ans;
        }
    }
    ```

### 打家劫舍问题

[198. 打家劫舍](https://leetcode.cn/problems/house-robber/description/)

=== "记忆化搜索"

    ```python
    class Solution:
        def rob(self, nums: List[int]) -> int:
            n = len(nums)

            @cache
            def dfs(idx):
                if idx < 0:
                    return 0
                return max(dfs(idx - 1), dfs(idx - 2) + nums[idx])

            return dfs(n - 1)
    ```

=== "线性 DP"

    ```python
    class Solution:
        def rob(self, nums: List[int]) -> int:
            n = len(nums)
            nums = [0, 0] + nums
            f = [0] * (n + 2)
            for i in range(2, n + 2):
                f[i] = max(f[i - 1], f[i - 2] + nums[i])
            return f[-1]
    ```

#### [213. 打家劫舍 II](https://leetcode.cn/problems/house-robber-ii/description/)

```java
class Solution {
    public int rob(int[] nums) {
        int n = nums.length;
        if (n == 1) return nums[0];
        int ans1 = rob(nums, 0, n - 2);
        int ans2 = rob(nums, 1, n - 1);
        return Math.max(ans1, ans2);
    }

    private int rob(int[] nums, int l, int r) {
        if (r == l) return nums[l];
        int[] dp = new int[nums.length];
        dp[l] = nums[l];
        dp[l + 1] = Math.max(nums[l], nums[l + 1]);
        for (int i = l + 2; i < nums.length; i++) {
            dp[i] = Math.max(dp[i - 2] + nums[i], dp[i - 1]);
        }
        return dp[r];
    }
}
```
