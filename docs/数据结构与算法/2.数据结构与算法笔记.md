## 排序

模板题：[912. 排序数组](https://leetcode.cn/problems/sort-an-array/)

### 快速排序

快速排序是基于分治的算法：

- 从数组中选取中轴元素 pivot
- 将小元素放在 pivot 左边，大元素放右边
- 然后分别对左边和右边的子数组进行快排

例题：
[215. 数组中的第 K 个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/description/)

```java
public class Main {
    public static void quickSort(int[] q, int l, int r) {
        if (l >= r) return;
        int x = q[l + r >> 1], i = l - 1, j = r + 1;
        while (i < j) {
            while (q[++i] < x) ;
            while (q[--j] > x) ;
            if (i < j) {
                int t = q[i];
                q[i] = q[j];
                q[j] = t;
            }
        }
        quickSort(q, l, j);
        quickSort(q, j + 1, r);
    }
}
```

```java
class Solution {
    public int[] sortArray(int[] nums) {
        quickSort(nums, 0, nums.length - 1);
        return nums;
    }

    public void quickSort(int[] arr, int l, int r) {
        if (l >= r) return;
        int pivot = partition(arr, l, r);
        quickSort(arr, l, pivot - 1);
        quickSort(arr, pivot + 1, r);
    }
    // partition函数：确定pivot，并调配好pivot左右的数组，返回pivot
    public int partition(int[] arr, int l, int r) {
        int randomIdx = l + (int)(Math.random() * (r - l + 1));
        swap(arr, randomIdx, r);
        int pivotVal = arr[r];
        // wall表示pivot最后的下标
        int wall = l;
        // for循环的意义是把比pivotVal小的元素移到前面
        for (int i = l; i <= r - 1; i++) {
            if (arr[i] < pivotVal) {
                swap(arr, i, wall);
                wall++;
            }
        }
        swap(arr, wall, r);
        return wall;
    }

    public void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }

}
```

[786. 第 k 个数](https://www.acwing.com/problem/content/description/788/)

```python
from random import random

n, k = map(int, input().split())
nums = list(map(int, input().split()))

def partition(nums, l, r):
    random_idx = l + int(random() * (r - l + 1))
    nums[random_idx], nums[r] = nums[r], nums[random_idx]
    pivot_val = nums[r]
    wall = l
    for i in range(l, r):
        if nums[i] < pivot_val:
            nums[i], nums[wall] = nums[wall], nums[i]
            wall += 1
    nums[wall], nums[r] = nums[r], nums[wall]
    return wall

def find_k(nums, k):
    target = k - 1
    left, right = 0, len(nums) - 1
    while left <= right:
        mid = partition(nums, left, right)
        if mid == target:
            return nums[mid]
        elif mid < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1

print(find_k(nums, k))
```

三路归并、荷兰国旗问题：给定一个数组`arr`和一个数`pivot`，使用` O(N)`的时间复杂度，将 < pivot 的数都放在左边，将 == pivot 的数放中间，将 > pivot 的数放右边。

```python
def partition(arr, pivot, l, r):
    l_wall = l
    r_wall = r
    i = l
    while i < r_wall:
        if arr[i] < pivot:
            arr[i], arr[l_wall] = arr[l_wall], arr[i]
            i += 1
            l_wall += 1
        elif arr[i] == pivot:
            i += 1
        else:
            arr[i], arr[r_wall] = arr[r_wall], arr[i]
            r_wall -= 1

arr = [3,5,6,3,4,5,2,6,9,0]
partition(arr, 5, 0, len(arr) - 1)
print(arr)
```

### 归并排序

归并排序是基于分治的排序算法

- 原问题：把数组排序
- 子问题：把数组前一半、后一半分别排序，然后再合并两半

```java
public class Sort {
    public void mergeSort(int[] arr, int l, int r) {
        if (l >= r) return;
        int mid = (l + r) / 2;
        mergeSort(arr, l, mid);
        mergeSort(arr, mid + 1, r);
        merge(arr, l, mid, r);
    }

    private void merge(int[] arr, int l, int mid, int r) {
        int[] temp = new int[r - l + 1];
        int i = l, j = mid + 1, idx = 0;
        while (i <= mid && j <= r) {
            if (arr[i] <= arr[j]) temp[idx++] = arr[i++];
            else temp[idx++] = arr[j++];
        }
        while (i <= mid) temp[idx++] = arr[i++];
        while (j <= r) temp[idx++] = arr[j++];
        for (int k = 0; k < temp.length; k++) {
            arr[l + k] = temp[k];
        }
    }
}
```

例题：[剑指 Offer 51. 数组中的逆序对](https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/description/)

```java
class Solution {
    int ans = 0;

    public int reversePairs(int[] nums) {
        mergeSort(nums, 0, nums.length - 1);
        return ans;
    }

    private void mergeSort(int[] nums, int l, int r) {
        if (l >= r) return;
        int mid = l + r >> 1;
        mergeSort(nums, l, mid);
        mergeSort(nums, mid + 1, r);
        merge(nums, l, mid, r);
    }

    private void merge(int[] nums, int l, int mid, int r) {
        int[] temp = new int[r - l + 1];
        int i = l, j = mid + 1, idx = 0;
        while (i <= mid && j <= r) {
            if (nums[i] <= nums[j]) temp[idx++] = nums[i++];
            else {
                ans += mid - i + 1;
                temp[idx++] = nums[j++];
            }
        }
        while (i <= mid) temp[idx++] = nums[i++];
        while (j <= r) temp[idx++] = nums[j++];
        for (int k = 0; k < temp.length; k++) {
            nums[l + k] = temp[k];
        }
    }
}
```

### 堆排序

```java
import java.util.*;

class Program {
    static int endIdx;

    public static int[] heapSort(int[] array) {
        int n = array.length;
        int[] heap = array;
        endIdx = n - 1;
        // O(n)建堆方式，从倒数第一个非叶子节点开始heapifyDown
        for (int i = (n - 1) / 2; i >= 0; i--) {
            heapifyDown(heap, i);
        }
        int[] ans = new int[n];
        for (int i = 0; i < n; i++) {
            ans[i] = heap[0];
            heap[0] = heap[endIdx];
            endIdx--;
            heapifyDown(heap, 0);
        }
        return ans;
    }

    public static void heapifyDown(int[] heap, int idx) {
        // 找到自己、左孩子、右孩子三者的最小值，即要交换到的目标下标
        int t = idx;
        if (2 * idx + 1 <= endIdx && heap[2 * idx + 1] < heap[t])
            t = 2 * idx + 1;
        if (2 * idx + 2 <= endIdx && heap[2 * idx + 2] < heap[t])
            t = 2 * idx + 2;
        if (idx != t) {
            int temp = heap[idx];
            heap[idx] = heap[t];
            heap[t] = temp;
            heapifyDown(heap, t);
        }
    }
}

```

```python
def heapify_up(arr, idx):
    while arr[idx] < arr[(idx - 1) // 2]:  # 父节点下标 (i - 1) // 2
        arr[idx], arr[(idx - 1) // 2] = arr[(idx - 1) // 2], arr[idx]
        idx = (idx - 1) // 2


def heapify_down(arr, idx):
    # 找到自己、左孩子、右孩子三者的最小值，即要交换到的目标下标
    t = idx
    left = 2 * idx + 1
    right = 2 * idx + 2
    if left < len(arr) and arr[left] < arr[t]:
        t = left
    if right < len(arr) and arr[right] < arr[t]:
        t = right
    if idx != t:
        arr[idx], arr[t] = arr[t], arr[idx]
        heapify_down(arr, t)


def heapify(arr):
    # O(N)建堆
    for i in range((len(arr) - 2) // 2, -1, -1):
        heapify_down(arr, i)


def heappop(arr):
    ans = arr[0]
    arr[0] = arr[-1]
    arr.pop()
    heapify_down(arr, 0)
    return ans


def heappush(arr, num):
    arr.append(num)
    heapify_up(arr, len(arr) - 1)

```

## 二分

### 经典二分

```java
class Solution {
    public int search(int[] nums, int target) {
        if (target < nums[0] || target > nums[nums.length - 1]) {
            return -1;
        }

        int left = 0, right = nums.length - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] == target)
                return mid;
            else if (nums[mid] < target)
                left = mid + 1;
            else if (nums[mid] > target)
                right = mid - 1;
        }
        return -1;
    }
}
```

### 后继型二分

查找第一个 `>=target` 的数的下标，不存在则返回 n。（后继型）

```java
class Solution {
    public int search(int[] nums, int target) {
        // nums.length是保护节点，由于往下取整永远不会被访问到，如果最后返回nums.length则表示无解
        int left = 0, right = nums.length;
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] >= target) { // 条件被满足的一侧应该被包含
                right = mid;
            } else {
                left = mid + 1; // 条件不满足的一侧直接去掉
            }
        }
        return right;
    }
}
```

### 前驱型二分

查找最后一个 `<= target` 的数的下标，不存在则返回 -1。（前驱型）

```java
class Solution {
    public int search(int[] nums, int target) {
        // -1是保护节点，由于向上取整永远不会被访问到，如果最后返回-1则表示无解
        int left = -1, right = nums.length - 1;
        while (left < right) {
            int mid = left + (right - left + 1) / 2; // 向上取整，避免陷入死循环
            if (nums[mid] <= target) { // 条件被满足的一侧应该被包含
                left = mid;
            } else {
                right = mid - 1; // 条件不满足的一侧直接去掉
            }
        }
        return right;
    }
}
```

## 双指针

```java
for (i = 0, j = 0; i < n; i++) {
    while (j < i && check(i, j)) j++;
    // 主要逻辑
}
```

例题：利用双指针实现 `String.split(" ")`

```java
public class Main {
    public static void main(String[] args) {
        String s = "abc def ghi";
        char[] arr = s.toCharArray();
        int n = s.length();
        for (int i = 0; i < n; i++) {
            int j = i;
            while (j < n && arr[j] != ' ') j++;
            for (int k = i; k < j; k++) System.out.print(arr[k]);
            System.out.println();
            i = j;
        }
    }
}
```

例题：[2511. 最多可以摧毁的敌人城堡数目](https://leetcode.cn/problems/maximum-enemy-forts-that-can-be-captured/)

例题：[3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/)

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        if (s.length()==0) return 0;
        HashMap<Character, Integer> map = new HashMap<>();
        int ans = 0;
        int left = 0;
        for (int i = 0; i < s.length(); i++) {
            map.put(s.charAt(i), map.getOrDefault(s.charAt(i), 0) + 1);
            while (map.get(s.charAt(i)) > 1) {
                map.put(s.charAt(left), map.get(s.charAt(left)) - 1);
                left++;
            }
            ans = Math.max(ans, i - left + 1);
        }
        return ans;
    }
}
```

## 位运算

例题：[191. 位 1 的个数](https://leetcode.cn/problems/number-of-1-bits/description/)

对于每个数字 a，`a&1`得到了该数字的最后一位，之后将 a 右移一位，直到为 0，就得到了 1 的个数

```python
class Solution:
    def hammingWeight(self, n: int) -> int:
        ans = 0
        for i in range(32):
            if (n >> i) & 1:
                ans += 1
        return ans
```

```python
class Solution:
    def hammingWeight(self, n: int) -> int:
        ans = 0
        while n:
            ans += 1
            n -= self.low_bit(n)
        return ans

    def low_bit(self, x):
        return x & (-x)
```

`lowbit(x)`：返回 x 的最后一位 1 及之后的数

热知识：`-x = ~x + 1`

| `x的二进制表示` | `lowbit(x)` |
| --------------- | ----------- |
| 1010            | 10          |
| 101000          | 1000        |

`lowbit(x) = x & -x = x & (~x + 1)`

## 区间和（离散化）

离散化的本质是建立了一段数列到自然数之间的映射关系（value -> index)，通过建立新索引，来缩小目标区间，使得可以进行一系列连续数组可以进行的操作比如二分，前缀和等。

⭐ 例题：[802. 区间和](https://www.acwing.com/problem/content/804/)

Java 的好处在于可以使用 TreeMap 的 `floorKey()` 进行二分查找，不用自己写二分查找的函数。

```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int m = sc.nextInt();
        TreeMap<Integer, Integer> map = new TreeMap<>();
        for (int i = 0; i < n; i++) {
            int x = sc.nextInt();
            int c = sc.nextInt();
            map.put(x, map.getOrDefault(x, 0) + c);
        }
        List<int[]> query = new ArrayList<>();
        for (int i = 0; i < m; i++) {
            int l = sc.nextInt();
            int r = sc.nextInt();
            query.add(new int[] { l, r });
        }
        int preSum = 0;
        for (int key : map.keySet()) {
            int curSum = map.get(key);
            map.put(key, curSum + preSum);
            preSum += curSum;
        }
        for (int[] q : query) {
            int l = q[0];
            int r = q[1];
            Integer l_key = map.floorKey(l - 1);
            Integer r_key = map.floorKey(r);
            Integer l_value = l_key == null ? 0 : map.get(l_key);
            Integer r_value = r_key == null ? 0 : map.get(r_key);
            System.out.println(r_value - l_value);
        }
    }
}
```

```python
from collections import Counter
from itertools import accumulate

n, m = map(int, input().split())
d = Counter()

for _ in range(n):
    x, c = map(int, input().split())
    d[x] += c

query = []
for _ in range(m):
    l, r = map(int, input().split())
    query.append((l, r))

def find(nums, target):
    left, right = -1, len(nums) - 1
    while left < right:
        mid = (left + right + 1) >> 1
        if nums[mid] <= target:
            left = mid
        else:
            right = mid - 1
    return right

keys = sorted(list(d.keys()))
values = [d[k] for k in keys]
pre_sum = list(accumulate(values))

for l, r in query:
    l_index = find(keys, l - 1)
    r_index = find(keys, r)
    l_value = pre_sum[l_index] if l_index != -1 else 0
    r_value = pre_sum[r_index] if r_index != -1 else 0
    print(r_value - l_value)

```

## 区间合并

[56. 合并区间](https://leetcode.cn/problems/merge-intervals/description/)

由于每次比较区间都是和数组的最后一个区间比较，因此也可以用`LinkedList`或者`Stack`存答案数组

```java
class Solution {
    public int[][] merge(int[][] intervals) {
        // 先按照区间起始位置排序
        Arrays.sort(intervals, (v1, v2) -> v1[0] - v2[0]);
        // 遍历区间
        int[][] res = new int[intervals.length][2];
        int idx = -1;
        for (int[] interval: intervals) {
            // 如果结果数组是空的，或者当前区间的起始位置 > 结果数组中最后区间的终止位置，
            // 则不合并，直接将当前区间加入结果数组。
            if (idx == -1 || interval[0] > res[idx][1]) {
                res[++idx] = interval;
            } else {
                // 反之将当前区间合并至结果数组的最后区间
                res[idx][1] = Math.max(res[idx][1], interval[1]);
            }
        }
        return Arrays.copyOf(res, idx + 1);
    }
}
```

[729. 我的日程安排表 I](https://leetcode.cn/problems/my-calendar-i/)

```java
class MyCalendar {
    TreeSet<int[]> set;

    public MyCalendar() {
        set = new TreeSet<>((a, b) -> a[0] - b[0]);
        set.add(new int[]{-1, -1});
        set.add(new int[]{(int)1e9 + 1, (int)1e9 + 1});
    }

    public boolean book(int start, int end) {
        // set.floor(E e): 返回set中 <= e 的最大元素
        // set.ceiling(E e): 返回set中 >= e 的最小元素
        int[] t = new int[]{start, end};
        int[] a = set.floor(t);
        int[] b = set.ceiling(t);
        if (!(start >= a[1] && end <= b[0])) return false;
        set.add(t);
        return true;
    }
}
```

## 前缀和与差分

[304. 二维区域和检索 - 矩阵不可变](https://leetcode.cn/problems/range-sum-query-2d-immutable/description/)

![image.png](https://cdn.nlark.com/yuque/0/2023/png/25849280/1687463798883-70df5750-9d40-445a-9b57-98657f73ab33.png#averageHue=%23bab9b9&clientId=u61d2f0ff-ab1f-4&from=paste&height=563&id=u2d8a35dc&originHeight=1125&originWidth=2000&originalType=binary&ratio=2&rotation=0&showTitle=false&size=201517&status=done&style=none&taskId=uec1e37ec-6da4-4e6e-8929-8635e46c813&title=&width=1000)

```java
class NumMatrix {
    int[][] preSum;

    // preSum[i][j]表示以(i, j)为右下角，(0, 0)为左上角的区域和
    public NumMatrix(int[][] matrix) {
        int m = matrix.length, n = matrix[0].length;
        preSum = new int[m + 1][n + 1];
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                preSum[i][j] = preSum[i - 1][j] + preSum[i][j - 1] - preSum[i - 1][j - 1] + matrix[i - 1][j - 1];
            }
        }
    }

    // 注意这里由于左上角是(row1, col1)，而我们preSum[i][j]的定义是右下角，因此左上角的的区域和其实是(row1 - 1, col1 - 1)
    // 另外我们要把原matrix的下标都+1转换到preSum对应的下标
    public int sumRegion(int row1, int col1, int row2, int col2) {
        int x1 = ++row1, y1 = ++col1, x2 = ++row2, y2 = ++col2;
        return preSum[x2][y2] - preSum[x2][y1 - 1] - preSum[x1 - 1][y2] + preSum[x1 - 1][y1 - 1];
    }
}
```

[797. 差分](https://www.acwing.com/problem/content/799/)

```python
n, m = map(int, input().split())
nums = [0] + list(map(int, input().split()))
queries = []
for _ in range(m):
    l, r, c = map(int, input().split())
    queries.append((l, r, c))

# 构建差分数组
diff = [0] * (n + 1)
for i in range(1, n + 1):
    diff[i] = nums[i] - nums[i - 1]


# 将序列中[l, r]之间的每个数都加上c
def add(l, r, c):
    diff[l] += c
    if r + 1 <= n:
        diff[r + 1] -= c


for l, r, c in queries:
    add(l, r, c)

ans = [0] * (n + 1)
# 前缀和求原数组
for i in range(1, n + 1):
    ans[i] = ans[i - 1] + diff[i]
    print(ans[i], end=" ")

```

[1109. 航班预订统计](https://leetcode.cn/problems/corporate-flight-bookings/description/)

```python
class Solution:
    def corpFlightBookings(self, bookings: List[List[int]], n: int) -> List[int]:
        ans = [0] * (n + 1)
        diff = [0] * (n + 1)

        def add(l, r, c):
            diff[l] += c
            if r + 1 <= n:
                diff[r + 1] -= c

        for l, r, c in bookings:
            add(l, r, c)

        for i in range(1, n + 1):
            ans[i] = ans[i - 1] + diff[i]

        return ans[1:]
```

[1094. 拼车](https://leetcode.cn/problems/car-pooling/description/)

```python
class Solution:
    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:
        diff = [0] * 1002

        def add(l, r, c):
            diff[l] += c
            if r + 1 < len(diff):
                diff[r + 1] -= c

        for c, l, r in trips:
            add(l, r - 1, c)

        ans = list(accumulate(diff))
        return all(x <= capacity for x in ans)
```

[6919. 使数组中的所有元素都等于零](https://leetcode.cn/problems/apply-operations-to-make-all-array-elements-equal-to-zero/)

```python
class Solution:
    def checkArray(self, nums: List[int], k: int) -> bool:
        n = len(nums)
        d = [0] * (n + 1)
        sum_d = 0
        for i, x in enumerate(nums):
            sum_d += d[i]
            x += sum_d
            if x == 0: continue  # 无需操作
            if x < 0 or i + k > n: return False  # 无法操作
            sum_d -= x  # 直接加到 sum_d 中
            d[i + k] += x
        return True
```

## 字符串算法

### KMP

[GFG](https://www.geeksforgeeks.org/kmp-algorithm-for-pattern-searching/)

```python
def get_next_array(t):
    if len(t) == 1:
        return [-1]
    next = [0] * len(t)
    next[0] = -1
    next[1] = 0
    i = 2
    cn = 0  # cn: 拿哪个位置的字符和 t[i-1] 比, 也是前缀的长度
    while i < len(next):
        if t[i - 1] == t[cn]:
            cn += 1
            next[i] = cn
            i += 1
        elif cn > 0:
            cn = next[cn]
        else:
            next[i] = 0
            i += 1
    return next


def get_index_of(s: str, t: str) -> int:
    i = j = 0
    next = get_next_array(t)
    while i < len(s) and j < len(t):
        if s[i] == t[j]:
            i += 1
            j += 1
        # 相当于 next[j] == -1, 已经往前跳不动了, 此时只能 i += 1 往下匹配
        elif j == 0:
            i += 1
        else:
            j = next[j]  # 往前跳
    # i 或 j 越界了
    return i - j if j == len(t) else -1


if __name__ == '__main__':
    s = "ABABDABACDABABCABAB"
    t = "ABABCABAB"
    print(get_index_of(s, t))
    print(s.find(t))

```

## 单调栈

例题：[830. 单调栈](https://www.acwing.com/problem/content/832/)

> 给定一个长度为 N 的整数数列，输出每个数左边第一个比它小的数，如果不存在则输出 −1。

```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] nums = new int[n];
        for (int i = 0; i < n; i++) {
            nums[i] = sc.nextInt();
        }
        Deque<Integer> stack = new ArrayDeque<>();
        for (int i = 0; i < n; i++) {
            while (!stack.isEmpty() && stack.peek() >= nums[i]) {
                stack.pop();
            }
            if (stack.isEmpty()) System.out.print(-1 + " ");
            else System.out.print(stack.peek() + " ");
            stack.push(nums[i]);
        }
    }
}
```

## 单调队列

⭐ 例题：[239. 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/description/)

思路：如果窗口中有 2 个元素下标为`i`和`j`(i < j)，并且`nums[i] < nums[j]`，那么`nums[i]`就没有存在的必要了（因为`nums[i]`既比`nums[j]`小，又比`nums[j]`先出队）。基于这个结论，我们就可以动态维护一个单调递减的单调队列。

```python
class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        n = len(nums)
        ans = []
        q = deque()
        for i in range(n):
            # 删除出界元素
            while q and q[0] <= i - k:
                q.popleft()
            # 维护单调递减队列
            while q and nums[i] >= nums[q[-1]]:
                q.pop()
            q.append(i)
            if i >= k - 1:
                ans.append(nums[q[0]])
        return ans
```

时间复杂度：`O(n)`，每一个下标恰好被放入队列一次，并且最多被弹出队列一次

空间复杂度：`O(k)`

```java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        // 大根堆存[值，下标]
        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> b[0] - a[0]);
        int[] ans = new int[nums.length - k + 1];
        for (int i = 0; i < nums.length; i++) {
            pq.offer(new int[]{nums[i], i});
            // 初始化到窗口长度为k的时候才开始更新答案
            if (i >= k - 1) {
                // 懒惰删除，检查堆顶的元素的下标是否在窗口中
                while (pq.peek()[1] <= i - k) pq.poll();
                ans[i - k + 1] = pq.peek()[0];
            }
        }
        return ans;
    }
}
```

时间复杂度：`O(nlogn)`，最差情况数组单调递增，没有元素被弹出，入堆操作为`logn`

空间复杂度：`O(n)`

## Trie

例题：

- [208. 实现 Trie (前缀树)](https://leetcode.cn/problems/implement-trie-prefix-tree/description/)
- [720. 词典中最长的单词](https://leetcode.cn/problems/longest-word-in-dictionary/)
- [212. 单词搜索 II](https://leetcode.cn/problems/word-search-ii/)
- [421. 数组中两个数的最大异或值](https://leetcode.cn/problems/maximum-xor-of-two-numbers-in-an-array/)

如果题目说明了只有小写英文字母的话，可以用数组代替哈希表实现

[835. Trie 字符串统计](https://www.acwing.com/problem/content/837/)

```python
class Trie:
    def __init__(self):
        self.count = 0
        self.children = {}

    def insert(self, word):
        cur = self
        for ch in word:
            if ch not in cur.children:
                cur.children[ch] = Trie()
            cur = cur.children[ch]
        cur.count += 1

    def search(self, word):
        cur = self
        for ch in word:
            if ch not in cur.children:
                return 0
            cur = cur.children[ch]
        return cur.count
```

```java
class Trie {
    int count; //词频
    HashMap<Character, Trie> children; //字符映射

    public Trie() {
        count = 0;
        children = new HashMap<>();
    }

    public void insert(String word) {
        Trie cur = this;
        for (char ch : word.toCharArray()) {
            if (!cur.children.containsKey(ch)) {
                cur.children.put(ch, new Trie());
            }
            cur = cur.children.get(ch);
        }
        cur.count++;
    }

    public boolean search(String word) {
        Trie cur = this;
        for (char ch : word.toCharArray()) {
            if (!cur.children.containsKey(ch)) {
                return false;
            }
            cur = cur.children.get(ch);
        }
        // 防止insert了"abc"但是要查找"a"的情况
        return cur.count > 0;
    }

    public boolean startsWith(String prefix) {
        Trie cur = this;
        for (char ch : prefix.toCharArray()) {
            if (!cur.children.containsKey(ch)) {
                return false;
            }
            cur = cur.children.get(ch);
        }
        return true;
    }
}
```

```java
class Trie {
    Trie[] children;
    boolean isEnd;

    public Trie() {
        children = new Trie[26];
        isEnd = false;
    }

    public void insert(String word) {
        Trie cur = this;
        for (char c : word.toCharArray()) {
            int idx = c - 'a';
            if (cur.children[idx] == null) {
                cur.children[idx] = new Trie();
            }
            cur = cur.children[idx];
        }
        cur.isEnd = true;
    }

    public boolean search(String word) {
        Trie cur = this;
        for (char c : word.toCharArray()) {
            int idx = c - 'a';
            if (cur.children[idx] == null) {
                return false;
            }
            cur = cur.children[idx];
        }
        return cur.isEnd;
    }

    public boolean startsWith(String prefix) {
        Trie cur = this;
        for (char c : prefix.toCharArray()) {
            int idx = c - 'a';
            if (cur.children[idx] == null) {
                return false;
            }
            cur = cur.children[idx];
        }
        return true;
    }
}
```

## 并查集

例题：

- [836. 合并集合](https://www.acwing.com/problem/content/838/)
- [837. 连通块中点的数量](https://www.acwing.com/problem/content/839/)
- [684. 冗余连接](https://leetcode.cn/problems/redundant-connection/description/?orderBy=most_votes)
- [547. 省份数量](https://leetcode.cn/problems/number-of-provinces/description/)

```java
class UnionFindSet {
    int[] fa;

    public UnionFindSet(int n) {
        fa = new int[n];
        for (int i = 0; i < n; i++) {
            fa[i] = i;
        }
    }

    public int find(int x) {
        if (x != fa[x]) {
            fa[x] = find(fa[x]);
        }
        return fa[x];
    }

    public void union(int x, int y) {
        x = find(x);
        y = find(y);
        if (x != y) {
            fa[x] = y;
        }
    }
}
```

```python
class UnionFind:
    def __init__(self, n):
        self.parent = list(range(n))
        self.n = n

    def find(self, x):
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]

    def union(self, x, y):
        x = self.find(x)
        y = self.find(y)
        if x != y:
            self.parent[x] = y

    def is_connected(self, x, y):
        x = self.find(x)
        y = self.find(y)
        return x == y
```

## 堆

[https://www.geeksforgeeks.org/binary-heap/](https://www.geeksforgeeks.org/binary-heap/)

[https://www.programiz.com/dsa/heap-data-structure](https://www.programiz.com/dsa/heap-data-structure)

![image.png](https://cdn.nlark.com/yuque/0/2023/png/25849280/1682572310484-f29c81c7-7605-454d-aa58-649e0bad25cd.png#averageHue=%23f8f7f7&clientId=ue6c8d41c-feba-4&from=paste&height=196&id=u82d80e32&originHeight=392&originWidth=334&originalType=binary&ratio=1&rotation=0&showTitle=false&size=19526&status=done&style=none&taskId=u60f5ce76-45e8-4ffa-a8ab-1633808cbae&title=&width=167)

heap 底层由数组实现，根节点在`Arr[0]`。

```python
Arr[(i-1)/2]	Returns the parent node
Arr[(2*i)+1]	Returns the left child node
Arr[(2*i)+2]	Returns the right child node
```

如何手写一个小根堆：如果数组下标从 0 开始

1. 插入一个数：`heap[size++] = x; up(size - 1);`
2. 求最小值：`heap[0];`
3. 删除最小值：`heap[0] = heap[size - 1]; size--; down(0);`
4. 删除第 k 个元素：`heap[k - 1] = heap[size - 1]; size--; down(k-1); up(k-1);`
5. 修改第 k 个元素：`heap[k - 1] = x; down(k-1); up(k-1);`

例题：[838. 堆排序](https://www.acwing.com/problem/content/840/)

```python
n, m = list(map(int, input().split()))
heap = list(map(int, input().split()))

# 找到自己、左孩子、右孩子三者的最小值，即要交换到的目标下标
def heapify(heap, i):
    smallest = i
    l = 2 * i + 1
    r = 2 * i + 2

    if l < len(heap) and heap[l] < heap[i]:
        smallest = l
    if r < len(heap) and heap[r] < heap[smallest]:
        smallest = r
    if smallest != i:
        heap[i], heap[smallest] = heap[smallest], heap[i]
        heapify(heap, smallest)

# O(n)建堆方式，从倒数第一个非叶子节点开始heapify Down
for i in range((len(heap) - 2) // 2, -1, -1):
    heapify(heap, i)

for i in range(m):
    print(heap[0], end=" ")
    heap[0] = heap[-1]
    heap.pop()
    heapify(heap, 0)

```

```python
def heapify_up(arr, idx):
    while arr[idx] < arr[(idx - 1) // 2]:  # 父节点下标 (i - 1) // 2
        arr[idx], arr[(idx - 1) // 2] = arr[(idx - 1) // 2], arr[idx]
        idx = (idx - 1) // 2


def heapify_down(arr, idx):
    # 找到自己、左孩子、右孩子三者的最小值，即要交换到的目标下标
    t = idx
    left = 2 * idx + 1
    right = 2 * idx + 2
    if left < len(arr) and arr[left] < arr[t]:
        t = left
    if right < len(arr) and arr[right] < arr[t]:
        t = right
    if idx != t:
        arr[idx], arr[t] = arr[t], arr[idx]
        heapify_down(arr, t)


def heapify(arr):
    # O(N)建堆
    for i in range((len(arr) - 2) // 2, -1, -1):
        heapify_down(arr, i)


def heappop(arr):
    ans = arr[0]
    arr[0] = arr[-1]
    arr.pop()
    heapify_down(arr, 0)
    return ans


def heappush(arr, num):
    arr.append(num)
    heapify_up(arr, len(arr) - 1)

```

## 字符串哈希

字符串哈希算法：[AcWing 841. 字符串哈希 【公式助理解】](https://www.acwing.com/solution/content/24738/)

在 Java 中，字符串 s 的 `hashcode()` 方法的实现为：

$s[0]*31^{n - 1} + s[1]*31^{n - 2} + ... + s[n - 1]$

`s[0] ... s[n-1]`代表 s 的下标为 i 处的字符的 ASCII 值，hashcode 计算方式是把整个长度为 n 的字符串看作一个位数为 n 的 31 进制数，hashcode 就是这个 31 进制数代表的 10 进制数。

```java
import java.util.*;

class Main {
    static int P = 31; // p是进制数
    static long[] h; // 这是存放hash前缀值的数组
    static long[] p; //这是存放p的n次方的数组

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int m = sc.nextInt();
        String s = sc.next();
        h = new long[n + 1];
        p = new long[n + 1];
        p[0] = 1; // p的0次方
        for (int i = 1; i <= n; i++) {
            p[i] = p[i - 1] * P;
            h[i] = h[i - 1] * P + s.charAt(i - 1);
        }
        for (int i = 0; i < m; i++) {
            int l1 = sc.nextInt();
            int r1 = sc.nextInt();
            int l2 = sc.nextInt();
            int r2 = sc.nextInt();
            if (hashcode(l1, r1) == hashcode(l2, r2)) System.out.println("Yes");
            else System.out.println("No");
        }
    }

    public static long hashcode(int l, int r) {
        return h[r] - h[l - 1] * p[r - l + 1];
    }
}
```

# 回溯

## 子集问题

- 元素无重不可复选：78. 子集
- 元素可重不可复选：90. 子集 II

## 组合问题

- 元素无重不可复选：77. 组合、216. 组合总和 III
- 元素可重不可复选：40. 组合总和 II
- 元素无重可复选：39. 组合总和

## 排列问题

- 元素无重不可复选：46. 全排列
- 元素可重不可复选：47. 全排列 II

## 切割问题

- 131.分割回文串
- 132.复原 IP 地址
- 133.单词拆分 II
- 剑指 Offer 46. 把数字翻译成字符串

```python
s = "apple"
n = len(s)
path = []
ans = []

def backtrack(idx):
    if idx == n:
        ans.append(path[:])
        return
    for i in range(idx, n):
        path.append(s[idx : i + 1])
        backtrack(i + 1)
        path.pop()

backtrack(0)
ans
```

# 搜索与图论

网格类搜索模板题：[200. 岛屿数量](https://leetcode.cn/problems/number-of-islands/description/)

图论模板题：[1971. 寻找图中是否存在路径](https://leetcode.cn/problems/find-if-path-exists-in-graph/description/)

## DFS

模板题：[DFS of Graph](https://practice.geeksforgeeks.org/problems/depth-first-traversal-for-a-graph/1?page=1&category[]=Graph&sortBy=submissions)

```java
class Solution {
    ArrayList<Integer> ans;
    ArrayList<ArrayList<Integer>> adj;
    boolean[] visited;

    public ArrayList<Integer> dfsOfGraph(int V, ArrayList<ArrayList<Integer>> adj) {
        ans = new ArrayList<>();
        this.adj = adj;
        visited = new boolean[V];
        dfs(0);
        return ans;
    }

    private void dfs(int s) {
        visited[s] = true;
        ans.add(s);
        for (int t : adj.get(s)) {
            if (!visited[t]){
                dfs(t);
            }
        }
    }
}
```

例题：[846. 树的重心](https://www.acwing.com/problem/content/848/)

![image.png](https://cdn.nlark.com/yuque/0/2023/png/25849280/1687546234767-6310d9ca-04cf-4602-831d-1a68098989d0.png#averageHue=%23fefcfc&clientId=u61d2f0ff-ab1f-4&from=paste&height=397&id=u796041c4&originHeight=397&originWidth=504&originalType=binary&ratio=2&rotation=0&showTitle=false&size=70792&status=done&style=none&taskId=ue8fda5df-94d3-41a1-9875-ec321fc5c4b&title=&width=504)

```python
from collections import defaultdict

n = int(input())
g = defaultdict(list)

for _ in range(n - 1):
    a, b = map(int, input().split())
    g[a].append(b)
    g[b].append(a)

vis = set()
ans = float("inf")

# 返回以u为根的子树中节点的个数，包括u节点
def dfs(u):
    global ans
    # 删掉某个节点之后，最大的连通子图节点数
    res = 0
    vis.add(u)
    # 以u为根的树的节点数, 包括u
    count = 1

    for v in g[u]:
        if v in vis:
            continue
        s = dfs(v)
        res = max(res, s)
        count += s

    res = max(res, n - count)
    ans = min(res, ans)
    return count

dfs(1)
print(ans)
```

例题：[200. 岛屿数量](https://leetcode.cn/problems/number-of-islands/description/)

```java
class Solution {
    int[] dx = new int[] {1, 0, -1, 0};
    int[] dy = new int[] {0, -1, 0, 1};
    boolean[][] visited;

    public int numIslands(char[][] grid) {
        int m = grid.length, n = grid[0].length;
        visited = new boolean[m][n];
        int ans = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == '1' && !visited[i][j]) {
                    dfs(grid, i, j);
                    ans++;
                }
            }
        }
        return ans;
    }

    private void dfs(char[][] grid, int x, int y) {
        if (!inArea(grid, x, y)) return;
        if (grid[x][y] != '1') return;
        if (visited[x][y]) return;
        visited[x][y] = true;
        for (int i = 0; i < 4; i++) {
            int nx = x + dx[i];
            int ny = y + dy[i];
            dfs(grid, nx, ny);
        }
    }

    private boolean inArea(char[][] grid, int x, int y) {
        int m = grid.length, n = grid[0].length;
        if (x < 0 || x >= m || y < 0 || y >= n) return false;
        return true;
    }
}
```

例题：[Cycle In Graph](https://www.algoexpert.io/questions/cycle-in-graph)

用`visited`记录已经遍历过的节点，用`inStack`记录当前路径上经过的节点。记得回溯。

```java
import java.util.*;

class Program {
    boolean[] visited;
    boolean[] inStack;

    public boolean cycleInGraph(int[][] edges) {
        int n = edges.length;
        visited = new boolean[n];
        inStack = new boolean[n];
        for (int i = 0; i < n; i++) {
            if (dfs(edges, i)) return true;
        }
        return false;
    }

    public boolean dfs(int[][] edges, int node) {
        visited[node] = true;
        inStack[node] = true;
        boolean hasCycle = false;
        for (int u : edges[node]) {
            if (!visited[u]) {
                hasCycle = dfs(edges, u);
            }
            if (visited[u] && inStack[u]) {
                return true;
            }
        }
        inStack[node] = false;
        return false;
    }
}
```

## BFS

模板题：[BFS of graph](https://practice.geeksforgeeks.org/problems/bfs-traversal-of-graph/1?page=1&category[]=Graph&sortBy=submissions)

```java
class Solution {
    public ArrayList<Integer> bfsOfGraph(int V, ArrayList<ArrayList<Integer>> adj) {
        ArrayList<Integer> ans = new ArrayList<>();
        boolean[] visited = new boolean[V];
        Deque<Integer> q = new ArrayDeque<>();
        q.offer(0);
        visited[0] = true;
        while (!q.isEmpty()) {
            int t = q.poll();
            ans.add(t);
            for (int s : adj.get(t)) {
                if (!visited[s]) {
                    q.offer(s);
                    visited[s] = true;
                }
            }
        }
        return ans;
    }
}
```

例题：[847. 图中点的层次](https://www.acwing.com/problem/content/849/)

```java
import java.util.*;

public class Main {
    static List<Integer>[] edges; // 出边数组
    static boolean[] used;
    static int[] distance; // distance[i]表示从bfs的起点到i的距离，本题即bfs(1)返回distance[n]

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int m = sc.nextInt();
        used = new boolean[n + 1];
        distance = new int[n + 1];
        Arrays.fill(distance, -1); // distance[]初始化为不可达
        edges = new List[n + 1];
        for (int i = 0; i <= n; i++) {
            edges[i] = new ArrayList<>();
        }
        for (int i = 0; i < m; i++) {
            int a = sc.nextInt();
            int b = sc.nextInt();
            edges[a].add(b);
        }
        bfs(1);
        System.out.println(distance[n]);
    }

    // 从点u出发的bfs
    public static void bfs(int u) {
        Queue<Integer> q = new ArrayDeque<>();
        q.offer(u);
        used[u] = true;
        distance[u] = 0; // 起点到自己的距离为0
        int d = 1;
        while (!q.isEmpty()) {
            int size = q.size();
            for (int i = 0; i < size; i++) {
                u = q.poll();
                for (int v : edges[u]) {
                    if (!used[v]) {
                        q.offer(v);
                        used[v] = true;
                        distance[v] = d;
                    }
                }
            }
            d++;
        }
    }
}
```

## 拓扑排序

例题：

- [848. 有向图的拓扑序列](https://www.acwing.com/problem/content/850/)
- [207. 课程表](https://leetcode.cn/problems/course-schedule/description/?orderBy=most_votes)

> 拓扑排序（Topological Sorting）是一个有向无环图（DAG）的所有顶点的线性序列。拓扑序列是一条满足图中有向边前后关系的序列，任一有向边起点在序列中一定早于终点出现。如果图中有环，则无法提取出拓扑序列。所以拓扑排序的一个重要应用是在给定的有向图中判定是否存在环路。

一个 DAG，一定至少有一个入度为 0 的点，拓扑排序从入度为 0 的点开始，各个击破。

拓扑排序问题：**常用于判断一个图是否是有向无环图（DAG）**

1. 根据依赖关系，构建邻接表、入度数组。
2. 选取入度为 0 的数据，根据邻接表，减小依赖它的数据的入度。
3. 找出入度变为 0 的数据，重复第 2 步。
4. 直至所有数据的入度为 0，得到排序，如果还有数据的入度不为 0，说明图中存在环。

为什么拓扑排序可以用来判环？因为如果有环，那么环上的点的入度都不为 0，我们的算法拿这个环无从下手。

```java
class Solution {
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        int n = numCourses;
        // 入度数组
        int[] inDegree = new int[n];
        // 邻接表建图
        List<Integer>[] edges = new List[n];
        for (int i = 0; i < n; i++) {
            edges[i] = new ArrayList<>();
        }
        for (int[] edge : prerequisites) {
            int to = edge[0];
            int from = edge[1];
            inDegree[to]++;
            edges[from].add(to);
        }
        // BFS
        Queue<Integer> q = new ArrayDeque<>();
        // 加入入度为0的节点
        for (int i = 0; i < n; i++) {
            if (inDegree[i] == 0) q.offer(i);
        }
        while (!q.isEmpty()) {
            int t = q.poll();
            for (int i : edges[t]) {
                inDegree[i]--;
                if (inDegree[i] == 0) q.offer(i);
            }
        }
        // 检查是否还有入度不为0的节点
        for (int x : inDegree) {
            if (x != 0) return false;
        }
        return true;
    }
}
```

## Dijkstra 算法

例题：

- [743. 网络延迟时间](https://leetcode.cn/problems/network-delay-time/description/)（多种算法通用）
- [849. Dijkstra 求最短路 I](https://www.acwing.com/problem/content/851/)
- [850. Dijkstra 求最短路 II](https://www.acwing.com/problem/content/852/)
- [1514. 概率最大的路径](https://leetcode.cn/problems/path-with-maximum-probability/description/?orderBy=most_votes)
- [1334. 阈值距离内邻居最少的城市](https://leetcode.cn/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/description/)（多种算法通用，Floyd 比较简单）

![](https://raw.githubusercontent.com/MXJULY/image/main/img/202307311636959.jpg#id=d1zwx&originHeight=1280&originWidth=2660&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)
![Dijkstra.jpg](https://cdn.nlark.com/yuque/0/2023/jpeg/25849280/1682587562118-26ba7ac4-602c-4e5a-8d59-b6bfea3c750c.jpeg#averageHue=%23f5f5f5&clientId=u285dd773-2f0c-4&from=paste&height=1500&id=u2b2aaa64&originHeight=1500&originWidth=2666&originalType=binary&ratio=2&rotation=0&showTitle=false&size=323257&status=done&style=none&taskId=u5637d3f6-4a56-45c9-840f-8ce9d6439a0&title=&width=2666)

※ [Dijkstra 算法图解](https://www.acwing.com/solution/content/38318/)

Dijkstra 算法适用于所有边权都是正数的单源最短路问题。

时间复杂度：`O(n^2)`

Dijkstra 求最短路的思路如下：

如果我们要求节点 1 到节点 n 的单源最短路，

- 用邻接矩阵建图（注意在遍历记录边之前要先把矩阵初始化为正无穷）
- 新建一个 visited 集合，用于保存确定了和 1 号节点的最短距离的点
- 新建 dist 数组，用于记录各个节点与 1 号节点的距离（除 1 号点之外初始化为正无穷）
- 循环 n-1 次，将 n-1 个点加入到 s 集合中
  1.  找到当前距离 1 号节点最近的节点
  2.  将这个节点加入 visited 集合中
  3.  由这个点更新其它节点到 1 号节点的距离

例题：[849. Dijkstra 求最短路 I](https://www.acwing.com/problem/content/851/)

```java
import java.util.*;

class Main {
    static int INF = Integer.MAX_VALUE / 2;
    static int n;
    static int m;

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        n = sc.nextInt();
        m = sc.nextInt();
        // 稠密图用邻接矩阵存图
        int[][] g = new int [n + 1][n + 1];
        // 初始化距离为正无穷
        for (int i = 1; i <= n; i++) Arrays.fill(g[i], INF);
        while (m-- > 0) {
            int x = sc.nextInt();
            int y = sc.nextInt();
            int z = sc.nextInt();
            g[x][y] = Math.min(g[x][y], z);
        }
        System.out.println(dijkstra(g));
    }

    public static int dijkstra(int[][] g) {
        int[] dist = new int[n + 1];
        // 相当于s集合，确定了和1号点的最短距离的点加入到s集合中
        boolean[] st = new boolean[n + 1];
        Arrays.fill(dist, INF);
        dist[1] = 0;
        // 循环n-1次，将除1节点外的n-1个点加入s集合中
        for (int i = 0; i < n - 1; i++) {
            // 找到当前距离1号点最近的点
            int t = -1;
            for (int j = 1; j <= n; j++) {
                if (st[j]) continue;
                if (t == -1 || dist[j] < dist[t]) {
                    t = j;
                }
            }
            st[t] = true;
            //更新其他节点到1号点的距离
            for (int j = 1; j <= n; j++) {
                dist[j] = Math.min(dist[j], dist[t] + g[t][j]);
            }
        }
        if (dist[n] == INF) return -1;
        return dist[n];
    }
}
```

```python
n, m = map(int, input().split())
inf = float('inf')
g = [[inf] * (n + 1) for _ in range(n + 1)]
for _ in range(m):
    x, y, z = map(int, input().split())
    g[x][y] = min(g[x][y], z)
dist = [inf] * (n + 1)
dist[1] = 0
state = [False] * (n + 1)

def dijkstra():
    for _ in range(n):
        x = -1
        for y in range(1, n + 1):
            if (state[y] == False) and (x == -1 or dist[y] < dist[x]):
                x = y
        state[x] = True
        for y, d in enumerate(g[x]):
            if d == inf: continue
            dist[y] = min(dist[y], dist[x] + d)
    if dist[n] == inf:
        return -1
    else:
        return dist[n]

print(dijkstra())
```

堆优化版：

时间复杂度：`O(mlogn)`

例题：[850. Dijkstra 求最短路 II](https://www.acwing.com/problem/content/852/)

```java
import java.util.*;

class Main {
    static int INF = Integer.MAX_VALUE / 2;
    static int n;
    static int m;

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        n = sc.nextInt();
        m = sc.nextInt();
        // 稀疏图用邻接表存图
        List<int[]>[] edges = new ArrayList[n + 1];
        for (int i = 0; i <= n; i++) {
            edges[i] = new ArrayList<>();
        }
        while (m-- > 0) {
            int x = sc.nextInt();
            int y = sc.nextInt();
            int z = sc.nextInt();
            edges[x].add(new int[] {y, z});
        }
        System.out.println(dijkstra(edges));
    }

    public static int dijkstra(List<int[]>[] edges) {
        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[1] - b[1]);
        int[] dist = new int[n + 1];
        // 相当于s集合，确定了和1号点的最短距离的点加入到s集合中
        boolean[] st = new boolean[n + 1];
        Arrays.fill(dist, INF);
        pq.offer(new int[] {1, 0});
        dist[1] = 0;
        while (!pq.isEmpty()) {
            int[] cur = pq.poll();
            int ver = cur[0];
            int distance = cur[1];
            if (st[ver]) continue;
            st[ver] = true;
            for (int[] v : edges[ver]) {
                dist[v[0]] = Math.min(dist[v[0]], distance + v[1]);
                pq.offer(new int[] {v[0], dist[v[0]]});
            }
        }
        if (dist[n] == INF) return -1;
        return dist[n];
    }
}
```

## Bellman-Ford 算法

Bellman-Ford 算法中可以存在负权边，但是不能存在负环。Bellman-Ford 常用在求带边数限制的单源最短路问题。好处是遍历边即可，不需要像 Dijkstra 那样自己建图。注意点是要每一轮更新要使用上一轮备份的 dist 数组，防止数据串联。

![第 15 课 图论算法.jpg](https://cdn.nlark.com/yuque/0/2023/jpeg/25849280/1682587485665-6caffa48-8bd6-451b-a199-7690bf422c9f.jpeg#averageHue=%23f7f7f7&clientId=u285dd773-2f0c-4&from=paste&height=1500&id=u029cf088&originHeight=1500&originWidth=2666&originalType=binary&ratio=2&rotation=0&showTitle=false&size=263440&status=done&style=none&taskId=ubc92393e-fc7a-44a3-825b-707af77982e&title=&width=2666)

例题：

- [853. 有边数限制的最短路](https://www.acwing.com/problem/content/description/855/)
- [743. 网络延迟时间](https://leetcode.cn/problems/network-delay-time/description/)
- [787. K 站中转内最便宜的航班](https://leetcode.cn/problems/cheapest-flights-within-k-stops/description/?orderBy=most_votes)（**带限制的单源最短路问题**）
- [1928. 规定时间内到达终点的最小花费](https://leetcode.cn/problems/minimum-cost-to-reach-destination-in-time/description/?orderBy=most_votes&page=2)

```python
# 单源最短路问题：Bellman-Ford算法
class Solution:
    def networkDelayTime(self, times: List[List[int]], n: int, k: int) -> int:
        dist = [inf] * (n + 1)
        dist[k] = 0
        # n个点中一条路径最多 n-1 条边
        # 循环 n-1 轮
        for _ in range(n - 1):
            backup = dist.copy()
            for x, y, z in times:
                dist[y] = min(dist[y], backup[x] + z)
        ans = max(dist[1:])
        if ans == inf:
            return -1
        return ans
```

总结：Dijkstra 算法需要自己建图，而 Bellman-Ford 算法不需要自己建图；Dijkstra 算法需要遍历点，而 Bellman-Ford 算法需要遍历边。

## Floyd-Warshall 算法

例题：

- [854. Floyd 求最短路](https://www.acwing.com/problem/content/856/)
- [743. 网络延迟时间](https://leetcode.cn/problems/network-delay-time/description/)
- [1334. 阈值距离内邻居最少的城市](https://leetcode.cn/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/description/)（多种算法通用）
- [399. 除法求值](https://leetcode.cn/problems/evaluate-division/description/?orderBy=most_votes)

是解决任意两点间的最短路径的一种算法，可以正确处理有向图或负权（但不可存在负权回路）的最短路径问题。时间复杂度为`O(n^3)`。

Floyd-Warshall 算法的原理是动态规划。
$设 D_{k,i,j}为从i到j的只以(1...k)集合中的节点为中间节点的最短路径的长度$
$1.若最短路径经过点k，则D_{k,i,j} = D_{k-1,i,k} + D_{k-1,k,j}$
$2.若最短路径不经过点k，则D_{k,i,j} = D_{k-1,i,j}$
$因此D_{k,i,j} = min(D_{k-1,i,j}, D_{k-1,i,k} + D_{k-1,k,j})$

```java
g = new int[n + 1][n + 1];

for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= n; j++) {
        if (i == j) g[i][j] = 0;
        else g[i][j] = INF;
    }
}

public static void floyd() {
    for (int k = 1; k <= n; k++) {
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n; j++) {
                g[i][j] = Math.min(g[i][j], g[i][k] + g[k][j]);
            }
        }
    }
}
```

例题：[854. Floyd 求最短路](https://www.acwing.com/problem/content/856/)

```python
n, m, k = map(int, input().split())
inf = float('inf')
g = [[inf] * (n + 1) for _ in range(n + 1)]

# 注意初始化g[i][i] = 0 !!!
for i in range(1, n + 1):
    g[i][i] = 0

for _ in range(m):
    x, y, z = map(int, input().split())
    g[x][y] = min(g[x][y], z)

def floyd():
    for k in range(1, n + 1):
        for i in range(1, n + 1):
            for j in range(1, n + 1):
                g[i][j] = min(g[i][j], g[i][k] + g[k][j])

floyd()
for _ in range(k):
    x, y = map(int, input().split())
    if g[x][y] == inf:
        print('impossible')
    else:
        print(g[x][y])
```

## Kruskal 算法

![image.png](https://cdn.nlark.com/yuque/0/2022/png/25849280/1671419578754-61a47918-4142-4839-a984-c048eab3a49f.png#averageHue=%23fefefe&clientId=u353510c5-64cf-4&from=paste&height=394&id=ud66855ab&originHeight=788&originWidth=1282&originalType=binary&ratio=1&rotation=0&showTitle=false&size=278151&status=done&style=none&taskId=u65980384-e028-468d-9d25-8281d02bd46&title=&width=641)

最小生成树（MST）问题的背景：有 n 个城市，如果要在城市间铺设公路，使得所有城市能够相互连通，求最小的公路的花费。

![image.png](https://cdn.nlark.com/yuque/0/2023/png/25849280/1687112396829-c22ec397-78e7-47f9-ac4b-e114a9c82a26.png#averageHue=%23f5f5f5&clientId=uccec0446-9e8b-4&from=paste&height=620&id=u1f6dcd4b&originHeight=1240&originWidth=2312&originalType=binary&ratio=2&rotation=0&showTitle=false&size=359104&status=done&style=none&taskId=ua9d84746-af24-4b35-b569-8f0ed847734&title=&width=1156)
![image.png](https://cdn.nlark.com/yuque/0/2023/png/25849280/1687112424173-6f6b2e6b-7abd-46be-b9fd-1bf0cf4fff8c.png#averageHue=%23f5f5f5&clientId=uccec0446-9e8b-4&from=paste&height=544&id=ufd6acc36&originHeight=1088&originWidth=2276&originalType=binary&ratio=2&rotation=0&showTitle=false&size=313435&status=done&style=none&taskId=u80148928-5a22-4710-925c-9ee5333f9cc&title=&width=1138)
例题：

- [1584. 连接所有点的最小费用](https://leetcode.cn/problems/min-cost-to-connect-all-points/description/?orderBy=most_votes)

```python
class UnionFind:
    def __init__(self, n):
        self.parent = list(range(n))
        self.n = n

    def find(self, x):
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]

    def union(self, x, y):
        x = self.find(x)
        y = self.find(y)
        if x != y:
            self.parent[x] = y

    def is_connected(self, x, y):
        x = self.find(x)
        y = self.find(y)
        return x == y

class Solution:
    def minCostConnectPoints(self, points: List[List[int]]) -> int:
        n = len(points)

        def get_dist(x, y):
            return abs(points[x][0] - points[y][0]) + abs(points[x][1] - points[y][1])

        uf = UnionFind(n)
        edges = []
        for i in range(n):
            for j in range(i + 1, n):
                edges.append((get_dist(i, j), i, j))

        edges.sort()

        ans = 0
        count = 1
        for z, x, y in edges:
            if uf.is_connected(x, y):
                continue
            uf.union(x, y)
            ans += z
            count += 1
            if count == n:
                break

        return ans
```

## 图论算法应用

无向图判环：

- [684. 冗余连接](https://leetcode.cn/problems/redundant-connection/description/?orderBy=most_votes)（并查集、拓扑排序、DFS、BFS）[题解](https://leetcode.cn/problems/redundant-connection/solutions/1594870/-by-yukiyama-mlqi/)

有向图判环：

- [207. 课程表](https://leetcode.cn/problems/course-schedule/description/?orderBy=most_votes)

# 数学知识

## 质数

```java
private int GCD(int a, int b) {
    if (b == 0) return a;
    return GCD(b, a % b);
}
```

例题：[866. 试除法判定质数](https://www.acwing.com/problem/content/868/)

```java
public static boolean isPrime(int n) {
    if (n < 2) return false;
    for (int i = 2; i <= n / i; i++) {
        if (n % i == 0) return false;
    }
    return true;
}
```

例题：[867. 分解质因数](https://www.acwing.com/problem/content/869/)

> 给定 n 个正整数，将每个数分解质因数，并按照质因数从小到大的顺序输出每个质因数的底数和指数。

```java
import java.util.*;

class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        while (n-- > 0) {
            int x = sc.nextInt();
            factorization(x);
        }
    }

    public static void factorization(int n) {
        for (int i = 2; i <= n / i; i++) {
            int count = 0;
            while (n % i == 0) {
                n /= i;
                count++;
            }
            if (count > 0) System.out.printf("%d %d\n", i, count);
        }
        if (n > 1) System.out.printf("%d %d\n", n, 1);
        System.out.println();
    }
}
```

```python
def prime_factors(n):
    i = 2
    factors = []
    while i * i <= n:
        if n % i:
            i += 1
        else:
            n //= i
            factors.append(i)
    if n > 1:
        factors.append(n)
    return factors
```

埃氏筛：
例题：[204. 计数质数](https://leetcode.cn/problems/count-primes/description/)

> 给定整数 n ，返回 所有小于非负整数 n 的质数的数量

```java
class Solution {
    public int countPrimes(int n) {
        boolean[] isPrime = new boolean[n + 1];
        Arrays.fill(isPrime, true);
        int ans = 0;
        for (int i = 2; i <= n / i; i++) {
            // 由于所有的合数都是质数的倍数，因此只要筛质数的倍数即可
            if (isPrime[i]) {
                for (int j = i + i; j < n; j += i) {
                    isPrime[j] = false;
                }
            }
        }
        for (int i = 2; i < n; i++) {
            if (isPrime[i]) ans++;
        }
        return ans;
    }
}
```

## 约数

例题：[869. 试除法求约数](https://www.acwing.com/problem/content/871/)

```java
import java.util.*;

class Main {
    static List<Integer> ans;

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        ans = new ArrayList<>();
        while (n-- > 0) {
            int x = sc.nextInt();
            ans.clear();
            getDivisors(x);
            Collections.sort(ans);
            for (int i : ans) {
                System.out.print(i + " ");
            }
            System.out.println();
        }
    }

    public static void getDivisors(int n) {
        for (int i = 1; i <= n / i; i++) {
            if (n % i == 0) {
                ans.add(i);
                if (i != n / i) ans.add(n / i);
            }
        }
    }
}
```

例题：[870. 约数个数](https://www.acwing.com/problem/content/872/)

对于一个大于 1 的正整数 n，可以分解质因数：

$n=\prod_{i=1}^k p_i^{a_i}=p_1^{a_1} \cdot p_2^{a_2} \cdots p_k^{a_k}$

则 n 的正约数的个数就是：

$f(n)=\prod_{i=1}^k\left(a_i+1\right)=\left(a_1+1\right)\left(a_2+1\right) \cdots\left(a_k+1\right)$

```java
import java.util.*;

class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        Map<Integer, Integer> primes = new HashMap<>();
        while (n-- > 0) {
            int x = sc.nextInt();
            for (int i = 2; i <= x / i; i++) {
                while (x % i == 0) {
                    x /= i;
                    primes.put(i, primes.getOrDefault(i, 0) + 1);
                }
            }
            if (x > 1) {
                primes.put(x, primes.getOrDefault(x, 0) + 1);
            }
        }
        long ans = 1;
        for (int prime : primes.values()) {
            ans = ans * (prime + 1) % ((int)1e9 + 7);
        }
        System.out.println(ans);
    }
}
```

最大公约数 & 最小公倍数

```java
private int gcd(int a, int b) {
    if (b == 0) return a;
    return gcd(b, a % b);
}

private int lcm(int a, int b) {
    return a * b / gcd(a, b);
}
```

## 同余定理

两个数 x 和 y，如果 (x−y)  mod  p = 0，则称 x 与 y 对模 p 同余，那么：

$x \mod\ p = y \mod\ p$

负数取模：如果 x < 0，y >= 0

$x \mod p + p = y \mod p$

## 快速幂

例题：

- [372. 超级次方](https://leetcode.cn/problems/super-pow/description/)
- [50. Pow(x, n)](https://leetcode.cn/problems/powx-n/)

[875. 快速幂](https://www.acwing.com/problem/content/description/877/)

```python
n = int(input())

def quick_multiply(a, b, p):
    if b == 1:
        return a % p
    if b % 2 == 0:
        t = quick_multiply(a, b // 2, p)
        return t * t % p
    else:
        t = quick_multiply(a, b // 2, p)
        return t * t * a % p

for _ in range(n):
    a, b, p = map(int, input().split())
    print(quick_multiply(a, b, p))
```

```python
n = int(input())

def quick_multiply(a, k, p):
    ans = 1
    while k:
        if k & 1:
            ans = ans * a % p
        a = a * a % p
        k >>= 1
    return ans


for _ in range(n):
    a, k, p = map(int, input().split())
    print(quick_multiply(a, k, p))

```

## 博弈论

例题：

- [292. Nim 游戏](https://leetcode.cn/problems/nim-game/)
- [877. 石子游戏](https://leetcode.cn/problems/stone-game/)
- [319. 灯泡开关](https://leetcode.cn/problems/bulb-switcher/)

# 贪心

## 区间选点

[905. 区间选点](https://www.acwing.com/problem/content/907/)

- 将每个区间按照右端点从小到大排序
- 从前往后依次枚举每个区间，如果当前区间已经包含该点，则直接 pass，否则，选择当前区间的右端点

```python
n = int(input())
intervals = []
for _ in range(n):
    l, r = map(int, input().split())
    intervals.append((l, r))

intervals.sort(key=lambda x: x[1])
ans = 0
pre = -float('inf')

for l, r in intervals:
    if l > pre:
        ans += 1
        pre = r

print(ans)
```

## 无重叠区间

[908. 最大不相交区间数量](https://www.acwing.com/problem/content/910/)

可以按前一题的方式将所有区间分为几个集合，每个集合中各个区间都至少有一点相交。若要选取不相交两个区间，那么两个区间必定处于不同的集合中，而最大的不相交区间数量便是总集合数，也就是区间选点的数量。所以两题代码相同。

```python
n = int(input())
intervals = []
for _ in range(n):
    l, r = map(int, input().split())
    intervals.append((l, r))

intervals.sort(key=lambda x: x[1])
ans = 0
pre = -float('inf')

for l, r in intervals:
    if l > pre:
        ans += 1
        pre = r

print(ans)
```

⭐ [435. 无重叠区间](https://leetcode.cn/problems/non-overlapping-intervals/description/)

为什么要按照右端点排序？因为无重叠区间问题本质是一个**会议问题**，按照右端点进行排序能够找到最早结束的会议，也就能给后面预留更多的时间。而如果按照左端点排序，则只能找到最早开始的会议，而不一定是最早结束的。例：

```
|_________|                  区间a
  |___|                      区间b
       |__|                  区间c
            |______|         区间d
```

也就是说：为了找到最多的不重叠区间，我们不在意区间的起点，而只在意终点越小越好（会议结束越早越好）。

```java
// 贪心区间问题模板题：求不相交区间最大数量 -> 选出最多数量的区间，使得它们互不重叠
// 时间复杂度：O(nlogn)
class Solution {
    public int eraseOverlapIntervals(int[][] intervals) {
        // 重点：按照右端点排序
        Arrays.sort(intervals, (a, b) -> a[1] - b[1]);
        int count = 0;
        int right = Integer.MIN_VALUE;
        for (int i = 0; i < intervals.length; i++) {
            if (intervals[i][0] >= right) {
                count++;
                right = intervals[i][1];
            }
        }
        return intervals.length - count;
    }
}
```

```java
// 时间复杂度：O(n^2)
// f[i]: 以区间 i 为最后一个区间，可以选出的不重叠区间数的最大值
// 本质是个最长上升子序列问题，可以优化至O(nlogn)
class Solution {
    public int eraseOverlapIntervals(int[][] intervals) {
        int n = intervals.length;
        Arrays.sort(intervals, (x, y) -> x[0] - y[0]);
        int[] f = new int[n];
        Arrays.fill(f, 1);
        for (int i = 1; i < n; i++) {
            for (int j = 0; j < i; j++) {
                if (intervals[j][1] <= intervals[i][0]) {
                    f[i] = Math.max(f[i], f[j] + 1);
                }
            }
        }
        int count = Arrays.stream(f).max().getAsInt();
        return n - count;
    }
}
```

## 区间分组

例题：⭐ [2406. 将区间分为最少组数](https://leetcode.cn/problems/divide-intervals-into-minimum-number-of-groups/description/)

按照左端点`left`排序后，用最小堆模拟，堆顶存储每个组最后一个区间的`right`。

遍历区间：

- 如果当前的`left`大于堆顶，则可以接在这个组的末尾，更新堆顶为`right`；
- 否则需要创建一个新的组。

```java
class Solution {
    public int minGroups(int[][] intervals) {
        Arrays.sort(intervals, (a, b) -> a[0] - b[0]);
        PriorityQueue<Integer> pq = new PriorityQueue<>();
        for (int[] p : intervals) {
            if (!pq.isEmpty() && pq.peek() < p[0]) {
                pq.poll();
            }
            pq.offer(p[1]);
        }
        return pq.size();
    }
}
```

## 区间覆盖

- [55. 跳跃游戏](https://leetcode.cn/problems/jump-game/description/)
- [45. 跳跃游戏 II](https://leetcode.cn/problems/jump-game-ii/description/)
- [ACW907. 区间覆盖](https://www.acwing.com/problem/content/909/)
- [1024. 视频拼接](https://leetcode.cn/problems/video-stitching/description/)
- [1326. 灌溉花园的最少水龙头数目](https://leetcode.cn/problems/minimum-number-of-taps-to-open-to-water-a-garden/description/)

例题：[907. 区间覆盖](https://www.acwing.com/problem/content/909/)

解题思路：

1. 将所有的区间按照左端点从小到大排序
2. 找到所有左端点小于等于当前要覆盖区间起点的线段，并取其中右端点最大的线段
3. 将起点更新为最大右端点

```python
start, end = map(int, input().split())
n = int(input())
intervals = []
for _ in range(n):
    l, r = map(int, input().split())
    intervals.append((l, r))

intervals.sort()
ans = 0
# i 代表当前正在考虑的区间的下标
i = 0
find = False

while True:
    # 每次循环都要重置 r 是为了避免出现之后扫描的区间的右端点都不够之前的 r
    r = -float('inf')
    # 遍历所有左端点 <= start 的区间（能覆盖start），找到最远的右端点
    while i < n and intervals[i][0] <= start:
        r = max(r, intervals[i][1])
        i += 1
    # 如果最远的右端点都 < start，无解
    if r < start:
        break
    ans += 1
    start = r
    if r >= end:
        find = True
        break

if find:
    print(ans)
else:
    print(-1)
```

# 动态规划

## 背包问题

### 01 背包

回溯记忆化搜索解法：

```python
def zero_one_knapsack(capacity: int, w: List[int], v: List[int]) -> int:
    n = len(w)

    @cache
    def dfs(i, c):
        if i < 0:
            return 0
        if w[i] > c:
            return dfs(i - 1, c)
        return max(dfs(i - 1, c), dfs(i - 1, c - w[i]) + v[i])

    return dfs(n - 1, capacity)

```

[2. 01 背包问题](https://www.acwing.com/problem/content/description/2/)

```python
n, V = map(int, input().split())
v = [0] * (n + 1)
w = [0] * (n + 1)
for i in range(1, n + 1):
    v[i], w[i] = map(int, input().split())

f = [[0] * (V + 1) for _ in range(n + 1)]

for i in range(1, n + 1):  # 遍历物品
    for j in range(V + 1):  # 遍历背包容量
        f[i][j] = f[i - 1][j]  # if j < v[i]，不选
        if j >= v[i]:  # 选，但是需要 j >= v[i]
            f[i][j] = max(f[i][j], f[i - 1][j - v[i]] + w[i])

print(f[n][V])
```

```python
n, V = map(int, input().split())
v = [0] * (n + 1)
w = [0] * (n + 1)
for i in range(1, n + 1):
    v[i], w[i] = map(int, input().split())

f = [0] * (V + 1)

for i in range(1, n + 1):
    for j in range(V, v[i] - 1, -1):
        f[j] = max(f[j], f[j - v[i]] + w[i])

print(f[V])
```

### 完全背包

完全背包问题和 01 背包问题唯一的区别是：完全背包问题中，每个物品有无数个，不再有最多 1 个的限制。
[3. 完全背包问题](https://www.acwing.com/problem/content/3/)

```java
import java.util.*;

class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int m = sc.nextInt();
        int[] v = new int[n + 1];
        int[] w = new int[n + 1];
        for (int i = 1; i <= n; i++) {
            v[i] = sc.nextInt();
            w[i] = sc.nextInt();
        }
        int[][] f = new int[n + 1][m + 1];
        for (int i = 1; i <= n; i++) {
            for (int j = 0; j <= m; j++) {
                for (int k = 0; k * v[i] <= j; k++) {
                    f[i][j] = Math.max(f[i][j], f[i - 1][j - k * v[i]] + k * w[i]);
                }
            }
        }
        System.out.println(f[n][m]);
    }
}
```

```java
import java.util.*;

class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int V = sc.nextInt();
        int[] v = new int[n + 1];
        int[] w = new int[n + 1];
        for (int i = 1; i <= n; i++) {
            v[i] = sc.nextInt();
            w[i] = sc.nextInt();
        }
        int[] f = new int[V + 1];
        for (int i = 1; i <= n; i++) {
            // 注意这里由于我们就是从第i层转移过来，因此从小到大遍历即可
            for (int j = v[i]; j <= V; j++) {
                f[j] = Math.max(f[j], f[j - v[i]] + w[i]);
            }
        }
        System.out.println(f[V]);
    }
}
```

### 多重背包

多重背包问题就是在完全背包问题的基础上，限制了每种物品的数量。
[4. 多重背包问题 I](https://www.acwing.com/problem/content/4/)

```python
n, V = map(int, input().split())
v = [0] * (n + 1)
w = [0] * (n + 1)
s = [0] * (n + 1)
for i in range(1, n + 1):
    v[i], w[i], s[i] = map(int, input().split())

f = [[0] * (V + 1) for _ in range(n + 1)]

for i in range(1, n + 1):
    for j in range(V + 1):
        k = 0
        while k <= s[i] and k * v[i] <= j:
            f[i][j] = max(f[i][j], f[i - 1][j - k * v[i]] + k * w[i])
            k += 1

print(f[n][V])
```

[5. 多重背包问题 II](https://www.acwing.com/problem/content/5/)

```python
import sys

n, V = map(int, sys.stdin.readline().split())
v, w, s = [0] * (n + 1), [0] * (n + 1), [0] * (n + 1)

for i in range(1, n + 1):
    v[i], w[i], s[i] = map(int, sys.stdin.readline().split())

f = [0] * (V + 1)
nv, nw = [0], [0]

for i in range(1, n + 1):
    a, b, c = v[i], w[i], s[i]
    k = 1
    while k <= c:
        nv.append(a * k)
        nw.append(b * k)
        c -= k
        k *= 2
    if c > 0:
        nv.append(a * c)
        nw.append(b * c)

for i in range(1, len(nv)):
    for j in range(V, nv[i] - 1, -1):
        f[j] = max(f[j], f[j - nv[i]] + nw[i])

print(f[V])
```

### 分组背包

[9. 分组背包问题](https://www.acwing.com/problem/content/9/)

```python
n, V = map(int, input().split())
v = [[] for _ in range(n + 1)]  # v[i][j]: 第i组的第j个物品的体积
w = [[] for _ in range(n + 1)]  # w[i][j]: 第i组的第j个物品的价值
s = [0] * (n + 1)  # s[i]: 第i组有s[i]个物品
for i in range(1, n + 1):
    s[i] = int(input())
    for _ in range(s[i]):
        a, b = map(int, input().split())
        v[i].append(a)
        w[i].append(b)
f = [[0] * (V + 1) for _ in range(n + 1)]

for i in range(1, n + 1):
    for j in range(0, V + 1):
        f[i][j] = f[i - 1][j]  # 不选
        for k in range(s[i]):  # 选
            if j >= v[i][k]:
                f[i][j] = max(f[i][j], f[i - 1][j - v[i][k]] + w[i][k])

print(f[n][V])
```

```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int V = sc.nextInt();
        List<List<Integer>> v = new ArrayList<>();
        List<List<Integer>> w = new ArrayList<>();
        int[] s = new int[n + 1];
        for (int i = 0; i <= n; i++) {
            v.add(new ArrayList<>());
            w.add(new ArrayList<>());
        }
        for (int i = 1; i <= n; i++) {
            s[i] = sc.nextInt();
            for (int j = 0; j < s[i]; j++) {
                int a = sc.nextInt();
                int b = sc.nextInt();
                v.get(i).add(a);
                w.get(i).add(b);
            }
        }
        int[][] f = new int[n + 1][V + 1];
        for (int i = 1; i <= n; i++) {
            for (int j = 0; j <= V; j++) {
                f[i][j] = f[i - 1][j];
                for (int k = 0; k < s[i]; k++) {
                    if (j >= v.get(i).get(k)) {
                        f[i][j] = Math.max(f[i][j], f[i - 1][j - v.get(i).get(k)] + w.get(i).get(k));
                    }
                }
            }
        }
        System.out.println(f[n][V]);
    }
}
```

## 线性 DP

[898. 数字三角形](https://www.acwing.com/problem/content/description/900/)

```python
n = int(input())
inf = float('inf')
g = [[-inf] * (n + 1) for _ in range(n + 1)]
for i in range(1, n + 1):
    line = list(map(int, input().split()))
    for j in range(1, len(line) + 1):
        g[i][j] = line[j - 1]

for i in range(2, n + 1):
    for j in range(1, i + 1):
        g[i][j] += max(g[i - 1][j - 1], g[i - 1][j])

print(max([g[n][j] for j in range(1, n + 1)]))
```

[895. 最长上升子序列](https://www.acwing.com/problem/content/897/)

```python
n = int(input())
nums = list(map(int, input().split()))
dp = [1] * n

for i in range(n):
    for j in range(i):
        if nums[i] > nums[j]:
            dp[i] = max(dp[i], dp[j] + 1)

print(max(dp))
```

[897. 最长公共子序列](https://www.acwing.com/problem/content/description/899/)
这道题对状态集合的划分的讲解：[https://www.acwing.com/file_system/file/content/whole/index/content/4814/](https://www.acwing.com/file_system/file/content/whole/index/content/4814/)
![image.png](https://cdn.nlark.com/yuque/0/2023/png/25849280/1683784390183-29843568-204d-4bf8-a3a3-4b44bcc3ceed.png#averageHue=%23a99f8b&clientId=ub6f99d89-c7d3-4&from=paste&height=770&id=uee3d4957&originHeight=1540&originWidth=3024&originalType=binary&ratio=2&rotation=0&showTitle=false&size=1929226&status=done&style=none&taskId=u348f60f1-0c8f-4e4a-885d-119a60c597f&title=&width=1512)

```python
m, n = map(int, input().split())
s1 = " " + input()
s2 = " " + input()

dp = [[0] * (n + 1) for _ in range(m + 1)]

for i in range(1, m + 1):
    for j in range(1, n + 1):
        dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
        if s1[i] == s2[j]:
            dp[i][j] = max(dp[i][j], dp[i - 1][j - 1] + 1)

print(dp[m][n])
```

## 区间 DP

区间 DP 例题：
[282. 石子合并](https://www.acwing.com/problem/content/284/)
[1068. 环形石子合并](https://www.acwing.com/problem/content/1070/)
[516. 最长回文子序列](https://leetcode.cn/problems/longest-palindromic-subsequence/description/)
[5. 最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/description/)
[1000. 合并石头的最低成本](https://leetcode.cn/problems/minimum-cost-to-merge-stones/description/)
[813. 最大平均值和的分组](https://leetcode.cn/problems/largest-sum-of-averages/description/)
[410. 分割数组的最大值](https://leetcode.cn/problems/split-array-largest-sum/description/)
[1039. 多边形三角剖分的最低得分](https://leetcode.cn/problems/minimum-score-triangulation-of-polygon/)
[312. 戳气球](https://leetcode.cn/problems/burst-balloons/description/)
[375. 猜数字大小 II](https://leetcode.cn/problems/guess-number-higher-or-lower-ii/description/)
[877. 石子游戏](https://leetcode.cn/problems/stone-game/)
[1335. 工作计划的最低难度](https://leetcode.cn/problems/minimum-difficulty-of-a-job-schedule/description/)

[282. 石子合并](https://www.acwing.com/problem/content/284/)
题意：合并 N 堆石子，每次只能合并相邻的两堆石子，求最小代价
解题思路：

- 关键点：最后一次合并一定是左边连续的一部分和右边连续的一部分进行合并
- 状态表示：`f[i][j]` 表示将 i 到 j 这一段石子合并成一堆的方案的集合，属性 Min

状态计算：
$f[i][j] = \min _{i \leqslant k \leqslant j-1}(f[i][k] + f[k+1][j] + presum[j] - presum[i-1])$

```java
// 预处理区间长度为1的情况
// 状态计算
for (int len = 2; len <= n; len++) { // 阶段：枚举区间长度
    for (int l = 1; l + len - 1 <= n; l++) { // 状态：枚举区间起点
        int r = l + len - 1; // 区间终点
        for (int k = l; k < r; k++) { // 决策：枚举分割点
            f[l][r] = min(f[l][r], f[l][k] + f[k + 1][r] + s[r] - s[l - 1]);
        }
    }
}
return f[1][n];
```

```python
n = int(input())
# 下标从1开始
stones = [0] + list(map(int, input().split()))

# 前缀和，由于数组下标从1开始，因此[i...j]区间和为 s[j] - s[i-1]
s = [0] * (n + 1)
for i in range(1, n + 1):
    s[i] = s[i - 1] + stones[i]

# dp[i][j]: 合并[i...j]区间的石头需要的最小体力
# 答案就是 dp[1][n]
dp = [[float("inf")] * (n + 1) for _ in range(n + 1)]

for i in range(1, n + 1):
    dp[i][i] = 0

# 枚举区间长度
for len in range(2, n + 1):
    # 枚举左端点i，右端点j = i + len - 1 <= n
    for i in range(1, n - len + 2):
        j = i + len - 1
        # 枚举分界点
        for k in range(i, j):
            dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + s[j] - s[i - 1])

print(dp[1][n])
```

```python
n = int(input())
# 下标从1开始
stones = [0] + list(map(int, input().split()))

# 前缀和，由于数组下标从1开始，因此[i...j]区间和为 s[j] - s[i-1]
s = [0] * (n + 1)
for i in range(1, n + 1):
    s[i] = s[i - 1] + stones[i]

memo = [[-1] * (n + 1) for _ in range(n + 1)]


# dfs(i, j): 合并区间[i...j]的最小体力
def dfs(i, j):
    if memo[i][j] != -1:
        return memo[i][j]
    if i == j:
        return 0
    ans = float("inf")
    for k in range(i, j):
        ans = min(ans, dfs(i, k) + dfs(k + 1, j) + s[j] - s[i - 1])
    memo[i][j] = ans
    return ans


print(dfs(1, n))
```

[516. 最长回文子序列](https://leetcode.cn/problems/longest-palindromic-subsequence/description/)

```python
class Solution:
    def longestPalindromeSubseq(self, s: str) -> int:
        n = len(s)
        memo = [[-1] * n for _ in range(n)]

        def dfs(i, j):
            if memo[i][j] != -1:
                return memo[i][j]
            if i == j:
                return 1
            if i > j:
                return 0
            ans = 0
            if s[i] == s[j]:
                ans = 2 + dfs(i + 1, j - 1)
            else:
                ans = max(dfs(i + 1, j), dfs(i, j - 1))
            memo[i][j] = ans
            return ans

        return dfs(0, n - 1)
```

## 树形 DP

[285. 没有上司的舞会](https://www.acwing.com/problem/content/287/)

```python
from collections import defaultdict
import sys
limit = 10000
sys.setrecursionlimit(limit)

n = int(input())
happy = [0] * (n + 1)
f = [[0, 0] for _ in range(n + 1)]
g = defaultdict(list)
has_father = [False] * (n + 1)

for i in range(1, n + 1):
    happy[i] = int(input())

for i in range(1, n):
    a, b = map(int, input().split())
    has_father[a] = True
    g[b].append(a)

root = 1
while has_father[root]:
    root += 1

def dfs(root):
    f[root][1] = happy[root]
    for child in g[root]:
        dfs(child)
        f[root][0] += max(f[child][1], f[child][0])
        f[root][1] += f[child][0]

dfs(root)
print(max(f[root][0], f[root][1]))
```

## 数位 DP

[1012. 至少有 1 位重复的数字](https://leetcode.cn/problems/numbers-with-repeated-digits/description/)

```python
class Solution:
    def numDupDigitsAtMostN(self, n: int) -> int:
        s = str(n)

        @cache  # 记忆化搜索
        def f(i: int, mask: int, is_limit: bool, is_num: bool) -> int:
            if i == len(s):
                return int(is_num)  # is_num 为 True 表示得到了一个合法数字
            ans = 0
            if not is_num:  # 可以跳过当前数位
                ans = f(i + 1, mask, False, False)
            # 如果前面没有填数字，必须从 1 开始（因为不能有前导零）
            low = 0 if is_num else 1
            # 如果前面填的数字都和 n 的一样，那么这一位至多填 s[i]（否则就超过 n 啦）
            up = int(s[i]) if is_limit else 9
            for d in range(low, up + 1):  # 枚举要填入的数字 d
                if (mask >> d & 1) == 0:  # d 不在 mask 中
                    ans += f(i + 1, mask | (1 << d), is_limit and d == up, True)
            return ans

        return n - f(0, 0, True, False)
```

[233. 数字 1 的个数](https://leetcode.cn/problems/number-of-digit-one/)

```python
class Solution:
    def countDigitOne(self, n: int) -> int:
        s = str(n)

        @cache
        def f(idx: int, one_cnt: int, is_limit: bool) -> int:
            if idx == len(s):
                return one_cnt
            up = int(s[idx]) if is_limit else 9
            ans = 0
            for digit in range(up + 1):
                ans += f(idx + 1, one_cnt + (digit == 1), is_limit and digit == up)
            return ans

        return f(0, 0, True)
```

[338. 计数问题](https://www.acwing.com/problem/content/340/)

```python
from functools import lru_cache
from collections import Counter

def count_digit(n, digit):
    s = str(n)

    @lru_cache(maxsize=None)
    def f(idx: int, digit_count: int, is_limit: bool, is_num: bool, digit: int) -> int:
        if idx == len(s):
            return digit_count if is_num else 0
        ans = 0
        if not is_num:
            ans = f(idx + 1, digit_count, False, False, digit)
        low = 0 if is_num else 1
        up = int(s[idx]) if is_limit else 9
        for d in range(low, up + 1):
            ans += f(idx + 1, digit_count + (d == digit), is_limit and d == up, True, digit)
        return ans

    return f(0, 0 if digit != '0' else 1, True, False, digit)


if __name__ == '__main__':
    while True:
        line = input()
        if line == "0 0":
            break
        a, b = map(int, line.split())
        a, b = min(a, b), max(a, b)
        c = Counter(str(a))
        for digit in range(10):
            ans = count_digit(b, digit) - count_digit(a, digit) + c[str(digit)]
            print(ans, end=" ")
        print()
```

# 树状数组与线段树

## 树状数组

树状数组（Binary Indexed Tree）是一种维护数组前缀和、区间和的数据结构。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/25849280/1693652287602-1ee6a32d-7622-443a-9c23-564e3c9da0d1.png#averageHue=%23f7f7f7&clientId=ub73cc8cb-15cf-4&from=paste&height=687&id=u27d623da&originHeight=1374&originWidth=2480&originalType=binary&ratio=2&rotation=0&showTitle=false&size=406332&status=done&style=none&taskId=u886c5ca4-6c27-42bd-af9e-2d881266b29&title=&width=1240)
树状数组内部每个节点`tree[x]`保存以它为根的子树中所有叶子结点的和。除树根外，每个内部节点`tree[x]`的父节点是`tree[x + lowbit(x)]`

树状数组支持的第一个操作：查询前缀和（前 x 个数据的和）

```java
int query(int x) {
    int ans = 0;
	while (x > 0) {
        ans += tree[x];
        x -= lowbit(x);
    }
	return ans;
}
```

因此，区间和（第`l`到第`r`个数据的和）即为：`query(r) - query(l-1)`
时间复杂度：`O(logN)`

树状数组支持的第二个操作：更新（把某个数据 x 增加一个值 delta）
需要更新`tree[x]`以及它的所有祖先
时间复杂度：`O(logN)`

```java
void add(int x, int delta) {
    while (x <= n) {
        tree[x] += delta;
        x += lowbit(x);
    }
}
```

[307. 区域和检索 - 数组可修改](https://leetcode.cn/problems/range-sum-query-mutable/)

```java
class NumArray {
    int[] tree, arr;
    int n;

    public NumArray(int[] nums) {
        this.n = nums.length;
        this.arr = new int[n + 1];
        for (int i = 1; i <= n; i++) {
            this.arr[i] = nums[i - 1];
        }
        this.tree = new int[n + 1];
        for (int i = 1; i <= n; i++) {
            add(i, arr[i]);
        }
    }

    private int lowbit(int x) {
        return x & -x;
    }

    // 单点增加（第 x 个数增加 delta），并向上动态修改父节点
    private void add(int x, int delta) {
        while (x <= n) {
            tree[x] += delta;
            x += lowbit(x);  // 求tree[x]的父节点: tree[x + lowbit(x)]
        }
    }

    // 查询前缀和（前 x 个数的和）
    private int query(int x) {
        int ans = 0;
        while (x > 0) {
            ans += tree[x];
            x -= lowbit(x);  // tree[x]节点中存了lowbit(x)个数
        }
        return ans;
    }

    public void update(int index, int val) {
        int idx = index + 1;  // tree 的下标是从 1 开始的，因此对应原数组 index + 1
        add(idx, val - arr[idx]);
        arr[idx] = val;
    }

    public int sumRange(int left, int right) {
        int l = left + 1, r = right + 1;
        return query(r) - query(l - 1);
    }
}
```

## 线段树

[307. 区域和检索 - 数组可修改](https://leetcode.cn/problems/range-sum-query-mutable/)

```java
class NumArray {
    private int[] segmentTree;
    private int n;

    public NumArray(int[] nums) {
        n = nums.length;
        segmentTree = new int[nums.length * 4];
        build(0, 0, n - 1, nums);
    }

    public void update(int index, int val) {
        change(index, val, 0, 0, n - 1);
    }

    public int sumRange(int left, int right) {
        return range(left, right, 0, 0, n - 1);
    }

    private void build(int node, int l, int r, int[] nums) {
        if (l == r) {
            segmentTree[node] = nums[l];
            return;
        }
        int m = l + (r - l) / 2;
        build(node * 2 + 1, l, m, nums);
        build(node * 2 + 2, m + 1, r, nums);
        segmentTree[node] = segmentTree[node * 2 + 1] + segmentTree[node * 2 + 2];
    }

    private void change(int index, int val, int node, int l, int r) {
        if (l == r) {
            segmentTree[node] = val;
            return;
        }
        int m = l + (r - l) / 2;
        if (index <= m) {
            change(index, val, node * 2 + 1, l, m);
        } else {
            change(index, val, node * 2 + 2, m + 1, r);
        }
        segmentTree[node] = segmentTree[node * 2 + 1] + segmentTree[node * 2 + 2];
    }

    private int range(int left, int right, int node, int l, int r) {
        if (left == l && right == r) {
            return segmentTree[node];
        }
        int m = l + (r - l) / 2;
        if (right <= m) {
            return range(left, right, node * 2 + 1, l, m);
        } else if (left > m) {
            return range(left, right, node * 2 + 2, m + 1, r);
        } else {
            return range(left, m, node * 2 + 1, l, m) + range(m + 1, right, node * 2 + 2, m + 1, r);
        }
    }
}
```
