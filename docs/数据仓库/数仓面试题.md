# 数仓面试题

## 数仓理论

### 数据库 VS 数据仓库

**数据库：**

数据库是面向业务的处理系统，主要针对业务在数据库的操作性处理，也被称为**联机事务处理 OLTP**，通常对记录进行查询、更新。

**数据仓库：**

数据仓库是面向主题的、集成的、非易失的且随时间变化的**数据集合**。数据仓库一般**针对某些主题的历史数据进行分析**、支持管理决策，又被称为**联机分析处理 OLAP**。

!!! note "区别"

    - 数据库是面向事务的设计，数据仓库是面向主题设计的。
    - 数据库一般存储业务数据，数据仓库存储的一般是历史数据。
    - 数据库设计是尽量避免冗余，常采用符合范式规范来设计。数据仓库设计关注数据整合、分析、处理性能，有意引入冗余，采用反范式设计。
    - 数据库主要操作是随机读写，数据仓库是为分析数据而设计，主要操作是批量读写。

---

### 数据仓库的四个特点

- **面向主题的**：数据仓库的数据是按照主题进行组织的，每个主题都能反应具体的业务需求，以电商数仓为例，常见主题有用户、商品、商户、交易、营销等。
- **集成的**：数据仓库中的数据从多个数据源中汇集，经过清洗、转换、统一而来的。
- **非易失的**：数据仓库中的数据以大量的查询为主，修改和删除的操作很少，只需要定期加载、更新即可。
- **随时间变化的**：数据仓库中的数据是反应历史变化的，包含从过去某一时间点至今的数据。

---

### 为什么需要建设数据仓库

- **维护历史数据**，可以基于历史数据进行分析，为企业提供决策支持。
- **减轻业务数据库的存储和计算压力**。
- 将多个数据源的数据进行整合，能够提供一个**统一的数据视图**，方便分析。
- 能够将多个数据源的数据进行**清洗、转换、统一**，**提高数据质量**。
- 基于分布式系统，能够提供**海量数据的存储能力以及高性能的计算能力**。
- 利用分层架构，能够**快速查询大量经整合的数据**，并减少重复的开发过程。

---

### 常见的数据仓库架构

**Inmon 架构：**

Inmon 架构的思想在于**自上而下地构建数据模型**。Bill Inmon 的方法强调更加集中、全面和结构化的数据仓库环境。 它**提倡标准化的数据模型**，其中数据被组织到单独的表中，以**消除冗余并保持数据完整性**。**其核心思想在于数仓分层**。

它使用“数据仓库总线”的概念来创建标准化、可重用的组件，并强调数据集成、转换和治理，以确保数据的准确性和一致性。换言之就是，尽量将某一主题域的所有数据都考虑到数据建模中。这样设计的数据模型的覆盖面会更广，但是数据模型的设计会更困难。

![](https://raw.githubusercontent.com/MXJULY/image/main/img/202312281718960.png)

**Kimball 架构：**

Kimball 架构的思想在于**自下而上地构建数据模型**。以具体业务需求为出发点，设计数据模型，**其核心思想在于维度建模**。（即根据业务需求找到关注的数据指标，基于关注的数据指标设计数据模型，这样设计的数据模型会更加的独立，但可能会导致数据模型过多发展）

Ralph Kimball 以其维度建模方法而闻名，该方法**专注于以针对最终用户查询和报告优化的方式提供数据**。 Kimball 方法侧重于使用星型模式结构创建数据仓库，其中中央事实表保存定量度量，维度表描述相关属性。 它是一种自上而下、迭代且敏捷的方法，强调通过构建特定于主题的数据集市来满足特定用户报告需求来快速交付业务价值。

![](https://raw.githubusercontent.com/MXJULY/image/main/img/202312281727600.png)

!!! note

    目前企业的数据仓库设计一般都是综合了两者的实现，整体上采用分层架构，具体的模型设计上采用维度建模。

**数据集市架构：**

数据集市是**按主题域组织的数据集合**，用于支持部门级的决策。

![](https://raw.githubusercontent.com/MXJULY/image/main/img/202312281729247.png)

**混合型数据仓库架构：**

所谓的混合型结构，指的是在一个数据仓库环境中，联合使用 Inmon 和 Kimball 两种架构。

这种架构将 Inmon 方法中的数据集市部分替换成了一个多维数据仓库，而数据集市则是多维数据仓库上的逻辑视图。

使用这种架构的好处是，既可以利用规范化设计消除数据冗余，保证数据的粒度足够细，又可以利用多维结构更灵活地在企业级实现报表和分析。

![](https://raw.githubusercontent.com/MXJULY/image/main/img/202312281730852.png)

---

### Kimball 数据仓库架构包括哪些模块

- **操作型系统/数据源**：包括各种数据源，如业务数据库、日志文件、外部数据等。
- **数据过渡区**：包括数据清洗、数据转换、数据集成等。
- **数据仓库**：维度建模，以星型模型或是雪花模型等方式构建维度数据仓库。
- **用户接口**：包括即席查询、报表、可视化、数据挖掘等。

---

### 对比 Inmon 和 Kimball 架构

**Inmon 架构：**

Inmon 架构的思想在于**自上而下地构建数据模型**，从数据源到数据仓库再到数据集市。**强调标准化的数据模型**，使用范式建模以**消除冗余并保持数据完整性**。**其核心思想在于数仓分层**。

其中的数据建模分为三个层次：高层模型、中间层模型、底层模型。

- ERD（实体关系图）是最顶层的概念模型，是实体关系的高度抽象，主要用于确定各个实体（或主题）及其之间的关系
- 中间层是数据集成（DIS），用于对主要数据分组，设置数据的链接，确定主键、属性和关系
- 底层是物理模型，用于设计关系表，在这一层上，确定数据的粒度、对数据进行分区、定义引用、创建索引等

**Kimball 架构：**

Kimball 架构的思想在于**自下而上地构建数据模型**，从数据源到数据集市再到数据仓库。根据业务需求找到关注的数据指标，再基于关注的数据指标设计数据模型。**其核心思想在于维度建模**，以星型模型或是雪花模型等方式构建维度数据仓库。

| Inmon 架构                                                                               | Kimball 架构                                                                         |
| :--------------------------------------------------------------------------------------- | :----------------------------------------------------------------------------------- |
| Inmon 架构由于采用了范式建模，所以数据模型的设计更加的规范，但是数据模型的设计会更困难。 | Kimball 架构由于采用了维度建模，所以数据模型的设计更加的灵活，但是维护的成本会更高。 |

---

### 介绍一下常见的数据模型

**关系数据模型/范式模型：**

关系数据模型是一种**二维表格模型**，它将数据组织成**行和列**的形式，每一行称为一个记录，每一列称为一个字段，每个字段只有一个值，每个记录都是唯一的。

关系数据模型的设计遵循一定的规范，即**范式**，范式分为六种，分别是第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式（4NF）、第五范式（5NF）。

**维度数据模型：**

按照事实表和维度表进行构建数仓和数据集市，以星型模型和雪花模型为主。切换不同维度的查询时非常的方便，有良好的扩展性能。

**Data Vault 模型：**

中心辐射式，中心表记录主键，链接表记录业务关系，附属表记录业务描述。

---

### 介绍一下三范式

!!! note "1NF"

    **确保表中的每列是原子、不可再分的。**

!!! note "2NF"

    在满足 1NF 的情况下，**不能存在部分依赖。**即非主键字段必须**完全依赖**于主键，而不能依赖于主键的一部分。

考虑一个订单明细表：`OrderDetail(OrderID，ProductID，UnitPrice，Discount，Quantity，ProductName)`。

因为我们知道在一个订单中可以订购多种产品，所以单单一个 OrderID 是不足以成为主键的，主键应该是 `(OrderID，ProductID)`。显而易见 `Discount` 和 `Quantity` 完全依赖于主键 `(OrderID，ProductID)`，而 `UnitPrice` 和 `ProductName` 只依赖于 `ProductID`。所以 OrderDetail 表不符合 2NF。不符合 2NF 的设计容易产生冗余数据。

可以把 OrderDetail 表拆分为 `OrderDetail(OrderID，ProductID，Discount，Quantity)` 和 `Product(ProductID，UnitPrice，ProductName)` 来消除原订单表中 `UnitPrice` 和 `ProductName` 多次重复的情况。

!!! note "3NF"

    在满足 2NF 的情况下，**不能存在传递依赖。** 3NF 是对字段冗余性的约束，要求任何字段不能由其他字段派生出来，它要求字段没有冗余，即不存在传递依赖。

考虑一个订单表 `Order(OrderID，OrderDate，CustomerID，CustomerName，CustomerAddr，CustomerCity)` 主键是 `(OrderID)`。

其中 `OrderDate, CustomerID, CustomerName, CustomerAddr, CustomerCity` 等非主键列都完全依赖于主键 `(OrderID)`，所以符合 2NF。不过问题是 `CustomerName, CustomerAddr, CustomerCity` 直接依赖的是 `CustomerID`（非主键列），而不是直接依赖于主键，它是通过传递才依赖于主键，所以不符合 3NF。

通过拆分 Order 为 `Order(OrderID，OrderDate，CustomerID)` 和 `Customer(CustomerID，CustomerName，CustomerAddr，CustomerCity)` 从而达到 3NF。

**第二范式（2NF）和第三范式（3NF）的概念很容易混淆，区分它们的关键点在于，2NF：非主键列是否完全依赖于主键，还是依赖于主键的一部分；3NF：非主键列是直接依赖于主键，还是直接依赖于非主键列。**

!!! note "反范式化"

    降低范式就是增加字段，允许冗余，达到以空间换时间的目的。

没有冗余的数据库设计可以做到。但是，没有冗余的数据库未必是最好的数据库，有时为了提高运行效率，就必须降低范式标准，适当保留冗余数据。

如订单表，“金额”这个字段的存在，表明该表的设计不满足第三范式，因为“金额”可以由“单价”乘以“数量”得到，说明“金额”是冗余字段。但是，增加“金额”这个冗余字段，可以提高查询统计的速度，这就是以空间换时间的作法。

---

### 列举一下你使用过的反范式化设计，并说明理由

- 逆 1NF：hive 里面的 map 结构
- 逆 2NF：log 日志表，做 PV、UV
- 逆 3NF：宽表设计

---

### 介绍一下星型模型、雪花模型和星座模型

**星型模型：**

**星型模式由事实表和维度表组成，一个星型模式中可以有一个或多个事实表，每个事实表引用任意数量的维表。**

![](https://raw.githubusercontent.com/MXJULY/image/main/img/202312281918072.png)

星型模式是**反范式化(denormalized)**的，**优点**是设计和实现起来比较简单，查询性能也比较高（join 的数量较少）。但是，星型模式的**缺点**是数据存储空间较大；而且，由于是非规范化的，数据的更新操作会更困难。星型模式的另一个缺点是对于分析需求来说不够灵活。它更偏重于为特定目的建造数据视图，因此实际上很难进行全面的数据分析。

**雪花模型：**

雪花模型是星型模型的扩展，**雪花模型是在星型模型的基础上，将维度表进一步范式化(normalized)**，即将维度表中的某些字段单独成表，这些字段和维度表的主键构成主外键关系。

![](https://raw.githubusercontent.com/MXJULY/image/main/img/202312281919853.png)

雪花模型的特点是**维度表的规范化程度更高**，因此**减少了数据冗余、节省了存储空间**，但是不可避免地增加了表的数量，因此**查询性能会有所下降**。

**星型 VS 雪花模型**

| 属性           | 星型模型 | 雪花模型           |
| :------------- | :------- | :----------------- |
| 数据总量       | 多       | 少                 |
| 可读性         | 高       | 低                 |
| 表个数         | 少       | 多                 |
| 查询速度       | 高       | 低                 |
| 数据冗余       | 多       | 少                 |
| 对事实表的情况 | 增加宽度 | 字段比较少，冗余低 |
| 拓展性         | 差       | 好                 |

**星型模型因为数据的冗余所以很多统计查询不需要做外部的连接，因此一般情况下效率比雪花型模型要高**。星型结构不用考虑很多范式化的因素，设计与实现都比较简单。

雪花型模型由于去除了冗余，有些统计就需要通过表的联接才能产生，所以效率不一定有星型模型高。范式化也是一种比较复杂的过程，相应的数据库结构设计、数据的 ETL、以及后期的维护都要复杂一些。**因此在冗余可以接受的前提下，实际运用中星型模型使用更多，也更有效率**。

**星座模型：**

星座模型是星型模型和雪花模型的混合体，**星座模型是在星型模型的基础上，多个事实表共享维度表**。

![](https://raw.githubusercontent.com/MXJULY/image/main/img/202312281933541.png)

---

### 介绍一下几种事实表并说明应用场景

1. **事务事实表**：记录的事务层面的事实，保存的是最原子的数据，也称“原子事实表”。事务事实表中的数据在事务事件发生后产生，数据的粒度通常是每个事务记录一条记录。

2. **周期快照事实表**：以具有规律性的、可预见的时间间隔来记录事实，时间间隔如每天、每月、每年等等。典型的例子如销售日快照表、库存日快照表等。它统计的是间隔周期内的度量统计，如历史至今、自然年至今、季度至今等等。

3. **累积快照事实表**：记录的不确定的周期的数据。累积快照事实表代表的是完全覆盖一个事务或产品的生命周期的时间跨度，它通常具有多个日期字段，用来记录整个生命周期中的关键时间点。例如订单累计快照事实表会有付款日期，发货日期，收货日期等时间点，还有数量、金额、运费这些事实字段。

---

### 维度设计过程中什么情况下需要进行维度整合？什么情况下需要进行维度拆分？

（1）维度整合：

将维度相关的维度属性做到统一。来源系统多的情况下，表名、字段名要统一。

案例 1：如 A 系统用户 ID 是 userid，B 系统是 user_id，维度表需要将这些统一；

案例 2：公共代码和编码值统一，如 A 系统男 1，女 0，B 系统男 M，女 F。

（2）维度拆分：

当一张维度表中包含多个类别、加工逻辑十分困难、有部分维度属性可以单独处理或者不常用时，考虑将维度拆分。

案例 1：水平拆分，例如航旅的商品和普通的商品，都属于商品，都有商品价格、标题、类型、上架时间、类目等维度属性，但是航旅的商品除了有这些公共属性外，还有酒店、景点、门票、旅行等自己独特的维度属性。可以考虑建单独的一张航旅商品维表进行维护。

案例 2：垂直拆分，当某些维度属性的来源表产出时间较早，而某些维度属性的来表产出时间较晚；或者某些维度属性的热度高、使用频繁，而某些维度属性的热度低、较少使用，都可以使用主从表垂直拆分。

---

### 如何处理缓慢变化维度

- **原样保留或者重写**

每个维度只保留一条最新的数据。这种方法主要应用于以下两种情况：

1. 数据必须正确——例如用户的身份证号，如需要更新则说明之前录入错误。
2. 无需考虑历史变化的维度——例如用户的头像 url，这种数据往往并没有分析的价值。因此不做保留。

这种处理方式的优点是：

1. 简化 ETL：直接 update 即可
2. 节省存储空间：其他存储方法都占用更多空间

---

- **增加新行**

每当维度发生变化的时候，插入新增的一行。采用此种方式，保留历史数据，维度值变化前的事实和过去的维度值关联，维度值变化后的事实和当前的维度值关联。

在这种场景下，具体的 ETL 过程如下：

1. 自然键第一次出现时，新增一行数据，created 为业务系统的创建时间，updated 为 9999-12-31（数仓的规范不允许数据存在 NULL 值的情况，因此用 9999-12-31 代替）。
2. 当维度发生变化时，将自然键当前记录的 updated 由 9999-12-31 刷为最新时间，新增一行记录，记录最新的数据，created 为最新时间，updated 为 9999-12-31。

---

- **增加新列**

当需要分析所有伴随着新值或旧值的变化前后记录的事实时，上述两种方法都不能解决问题。这时我们可以添加维度列，采用这种方式，主要是为了将变化前后记录的事实归为变化前的维度或者归为变化后的维度。也就是将产生变化的维度，可以在汇总的时候按照统一分组处理。

假定一家公司的销售是按照销售区域进行分组：

![](https://raw.githubusercontent.com/MXJULY/image/main/img/202312192313976.png)

突然有一天，东部、南部、北部被重新划分为东南、东北部。

![](https://raw.githubusercontent.com/MXJULY/image/main/img/202312192314964.png)

但由于发送的过于仓促，因此销售人员是立刻使用了新的部门划分；但同样希望保留旧的名称——至少要暂时保留，用以比较今年和去年的业绩。即：

- 拥有使用 新区域 分析所有事实的能力，无论变化前还是变化后
- 拥有使用 旧区域 分析所有事实的能力，无论变化前还是变化后

重写可以满足第一种需求，使用新值写旧值，但显然它无法实现第二个需求；增加新行则更糟，它不能满足任意一个需求——旧的事实和旧的维度相连；而新的维度值和以后的事实相连。毫无疑问，它既不能分析旧数据、也不能分析新数据。此时引入第 3 种处理方法：新增字段同时储存新旧值。

![](https://raw.githubusercontent.com/MXJULY/image/main/img/202312192316442.png)

如果发生第二次变化，当前的 current 会被更新到 previous 中，新的变化值则会写入 current。当然我们也可以看到，新增维度列，这种只合适变化频率非常非常低的维度属性（毕竟频繁变化我们不可能会一直新增列来保存，特殊情况除外）。

---

- **快照存储**

每一个周期定时保存一份数据，不过会产生很多冗余的数据，当维度里大部分行在周期内，变动频繁的时候，可以采用。

- **历史拉链存储**

**历史拉链表是维护了历史状态，以及最新状态数据的一种表**。拉链表存储的数据实际上相当于快照，只不过做了优化，去除了一部分不变的记录而已，通过拉链表可以很方便的还原出拉链时点的客户记录。拉链表既能满足反应数据的历史状态，又可以最大程度的节省存储，提高查询效率。

历史拉链存储是基于处理缓慢变化维的第 2 种方法来加工的，也就是：新建维度行。但不同的是，**拉链存储特地用了两个时间键（生效时间和失效时间）来替代原有的代理键**。

历史拉链存储一般应用场景：针对变化频率不频繁的维度表或者是周期性事实表，如修改商品名称、修改身份证名称、订单状态变更、用户状态变更等。

这样一来，当我们需要查询商品最新记录时，只需要让 `结束时间 = '9999-12-31'`

`select * from 商品维表 where 结束时间 = '9999-12-31'`

同样，如果我们想查商品在 2021-01-01 的所有商品状态：

`select * from 商品维表 where 开始时间 <= '2021-01-01' and 结束时间 >= '2021-01-01'`。

---

### 数仓建模的基本流程

1. 沟通业务需求、技术需求
2. 逻辑设计，细化需求中的数据、理清数据之间的关系
3. 物理设计，建表、合理设置分区
4. 数据处理，数据抽取、转化、加载
5. 数据应用构建与数据使用
6. 数据维护
7. 数据质量保障和维护

---

### 在数据处理的各个阶段，使用过哪些工具

1. 数据同步：sqoop、datax、canal
2. 数据抽取工具：Kafka、flume
3. 数据清洗：hive、tez、spark、presto、link
4. 数据存储：hadoop、hbase、ES、redis、tair
5. 任务管理：azkaban、oozie、airflow、DolphinScheduler

---

### 数据质量包括哪些方面

1. **完整性**：是指数据的记录和信息是否完整，是否存在缺失的情况。
2. **准确性**：是指数据中记录的信息和数据是否准确，是否存在异常或者错误的信息。
3. **一致性**：一般体现在跨度很大的数据仓库体系中，比如阿里巴巴数据仓库，内部有很多业务数据仓库分支，对于同一份数据，必须保证一致性。
4. **及时性**：指的是保障数据能够及时产出。

---

### DQC

1. DQC(Data Quality Check)，数据质量检查。通过配置 DQC 的数据质量校验规则，可以实现在数据处理过程中进行自动的数据质量监控。DQC 可以监控数据质量并报警，但它不对数据产出进行处理，需要报警接收人判断如何处理。
2. 核心作用：对核心的维度、指标数据进行监控。例如主键是否唯一，量级是否符合预期，维度等是否做了非空处理，指标字段数据类型精度等是否有问题。

---

### SLA

在数据质量管理中，SLA 指的应该是最晚出数时间。通过上游血缘任务最迟的一个产出时间，计算本次上线任务预计执行时长，是否有数据倾斜等性能风险，是否需要挂载基线且无破线风险。

---

### 什么是总线矩阵

总线矩阵：是**对业务过程、一致性维度的划分**，主要呈现的是两者之前的关系。

构建总线矩阵：核心需要做两件事情：

1. 明确每个数据域下有哪些业务过程。
2. 业务过程与哪些维度相关，并通过总线矩阵定义每个数据域下的业务过程和维度。

---

### 维度建模的基本流程

维度建模主要涉及 5 个主要的过程:

1. **需求收集**：收集业务需求，在开始维度建模工作之前，需要理解业务需求，以及作为底层源数据的实际情况。通过与业务方沟通交流、查看现有报表等来发现需求，用于理解他们的基于关键性能指标、决策制定过程、支持分析需求的目标。
2. **选择业务过程**：选择需要进行分析的业务过程。业务过程可以是单个业务事件，比如交易的支付、退款等；也可以是某个事件的状态，比如当前的账户余额等；还可以是一系列相关业务事件组成的业务流程。过程的选择非常重要的，因为**过程定义了特定的设计目标以及对粒度、维度、事实的定义。**
3. **声明粒度**：粒度用于确定事实表中的每一行所表示的业务含义。在选择维度或事实前必须声明粒度，因为每个候选维度或事实必须与定义的粒度保持一致。在从给定的业务过程获取数据时，原子粒度是最低级别的粒度。
4. **确认维度**：维度是分析事实所需要的环境/角度。例如在分析交易过程时，可以通过商品、买家、卖家、时间等维度来分析交易过程。
5. **确认事实**：事实是业务过程的度量，基本上都是以数据值表示。事实有可加性、半可加性和非可加性三种类型，需要将非可加性事实分解为可加的组件。

在建模期间，需要考虑业务需求以及协作建模阶段涉及的底层数据源。从上述维度建模步骤来看，重点在解决数据粒度、维度设计和事实表设计问题。

![](https://raw.githubusercontent.com/MXJULY/image/main/img/202401132006120.png)

例如：交易域中的**订单付款**业务过程，其粒度是每笔子订单，维度是买家、商品、卖家、订单时间等，事实是订单金额、订单数量等。

---

**维度的基本设计方法**

1. **选择或者新建一个维度**，通过之前总线矩阵的构建掌握了目前数仓架构中的维度。
2. **确定主维表**。此处主维表一般是 ODS 表，直接与业务系统同步。
3. **确定相关维表**。数仓是业务源系统的数据整合，不同业务系统或者同一业务系统中的表之间存在关联性。跟据对业务的梳理，我们可以确认哪些表和主维表存在关联关系，并选择其中的某些表用于生成维度属性。
4. **确定维度属性**。本步骤分为两阶段，第一阶段是从主维表中选择维度属性或生成新的维度属性；第二阶段是从相关维表中选择维度属性或生成新的维度属性。

以商品维度举例：

1. 选择维度：商品维度
2. 确定主维表：商品表
3. 确定相关维表：商品分类表、商品品牌表、SPU 表等
4. 确定维度属性：商品表中的商品 ID、商品名称、商品价格等；商品分类表中的商品分类 ID、商品分类名称等；商品品牌表中的商品品牌 ID、商品品牌名称等；SPU 表中的商品 SPU ID、商品 SPU 名称等。

---

### 为什么要做数仓分层

1. **清晰数据结构**：每一个数据分层都有**对应的作用域**，在使用数据的时候能更方便的定位和理解。

2. **数据血缘追踪**：提供给业务人员或下游系统的数据服务时都是目标数据，目标数据的数据来源一般都来自于多张表数据。若出现目标数据异常时，**清晰的血缘关系可以快速定位问题所在**。而且，血缘管理也是元数据管理重要的一部分。

3. **减少重复开发**：数据的逐层加工原则，下层包含了上层数据加工所需要的全量数据，这样的加工方式避免了每个数据开发人员都重新从源系统抽取数据进行加工。

4. **数据关系条理化**：源系统间存在复杂的数据关系，数据仓库会对相同主题的数据进行统一建模，**把复杂的数据关系梳理成条理清晰的数据模型**。

5. **屏蔽原始数据的影响**：数据的逐层加工原则，上层的数据都由下一层的数据加工获取，不允许跳级取数。而原始数据位于数仓的最底层，离应用层数据还有多层的数据加工，所以加工应用层数据的过程中就会**把原始数据的变更消除掉，保持应用层的稳定性**。

---

### 介绍 ods 层、dwd 层、dws 层、ads 层

- 贴源层（ODS，Operational Data Store，又称数据基础层）：将原始数据几乎无处理地存放在数据仓库系统中，结构上与源系统基本保持一致，是数据仓库的数据准备区。

- 维度层（DIM，Dimension）：**以维度作为建模驱动**，基于每个维度的业务含义，通过添加维度属性、关联维度等定义计算逻辑，完成属性定义的过程并**建立一致的数据分析维表**。

- 明细层（DWD，Data Warehouse Detail）：**以业务过程作为建模驱动**，基于每个具体的业务过程特点，**构建最细粒度的明细事实表**。可以结合企业的数据使用特点，将明细事实表的某些重要属性字段做适当冗余，也即宽表化处理。

- 汇总层（DWS，Data Warehouse Summary）：**以分析的主题对象作为建模驱动**，基于上层的应用和产品的指标需求，**构建公共粒度的汇总指标表**。以宽表化手段物理化模型，构建命名规范、口径一致的统计指标，为上层提供公共指标。

- 数据应用层（ADS，Application Data Store）：**存放数据产品个性化的统计指标数据**，根据 CDM 层与 ODS 层加工生成。

---

### 介绍一下数仓主题的划分原则

1. 按照业务过程来划分，对业务过程进行一个抽象，从而得到主题域。
2. 按照数据域来划分，比如把商品、用户作为分析对象，那相应的主题域就是商品主题域、用户主题域。

---

### 数据模型设计过程中需要遵循哪些基本原则

1. 高内聚，低耦合
2. 核心模型与扩展要分离
3. 公共处理低层封装
4. 适当的数据冗余可以使成本性能相平衡
5. 数据可回滚
6. 命名规范，清晰且一致

---

### 请举例说说数仓层次调用的过程中需要遵循哪些基本的规范

总体遵循的层次调用原则如下：

- ODS 层数据不能直接被应用层任务引用。如果中间层没有沉淀的 ODS 层数据，则通过 CDM 层的视图访问。CDM 层视图必须使用调度程序进行封装，保持视图的可维护性与可管理性。
- CDM 层任务的深度不宜过大（建议不超过 10 层）。
- 一个计算刷新任务只允许一个输出表，特殊情况除外。
- CDM 汇总层优先调用 CDM 明细层，可累加指标计算。CDM 汇总层尽量优先调用已经产出的粗粒度汇总层，避免大量汇总层数据直接从海量的明细数据层中计算得出。
- CDM 明细层累计快照事实表优先调用 CDM 事务型事实表，保持数据的一致性产出。
- 有针对性地建设 CDM 公共汇总层，避免应用层过度引用和依赖 CDM 层明细数据。

---

## 项目类

### 请介绍一下电商中常见的用户指标、流量指标、搜索指标、商品指标、订单交易指标

**用户指标：**

- 注册用户数：注册电商平台用户数；
- 活跃用户数：登录 APP 用户数；
- 浏览商详用户数：浏览商品详情页用户数；
- 新用户数：历史成交订单数为 0 的用户数；
- 老用户数：历史成交订单数大于 0 的用户数；
- 复购用户数：历史成交订单数大于 1 的用户数；
- 沉默用户数：距离上次登录 APP 大于 30 天，小于 90 天的用户数；
- 流失用户数：距离上次登录 APP 大于等于 90 天的用户数。

---

**流量指标：**

- 页面曝光 UV；
- 页面曝光 PV；
- 页面点击 UV；
- 页面点击 PV；
- 页面 UV 点击率=页面点击 UV/页面曝光 UV；
- 页面 PV 点击率=页面点击 PV/页面曝光 PV；
- 人均曝光=页面曝光 PV/页面曝光 UV；
- 人均点击=页面点击 PV/页面点击 UV。

---

**搜索指标：**

- 搜索曝光 UV；
- 搜索曝光 PV；
- 搜索点击 PV；
- 搜索点击 PV；
- 搜索 UV 使用率=搜索点击 UV/搜索曝光 UV；
- 搜索 PV 使用率=搜索点击 PV/搜索曝光 PV；
- 人均搜索次数=搜索点击 PV/搜索点击 UV；
- 人均搜索词量=（搜索有结果词量+搜索无结果词量）/搜索点击 UV。

---

**商品指标：**

- 商品数量；
- 商品上新数量；
- 商品有库存数量；
- 商品无库存数量；
- 商品有销售数量；
- 商品无销售数量；
- 商品上新率=商品上新数量 /商品数量；
- 商品动销率=商品有销售数量 /商品数量；
- 商品滞销率=商品无销售数量 /商品数量；
- 商品倾销率=商品无库存数量 /商品数量。

---

**订单交易指标：**

- 下单数量；
- 下单人数；
- 下单金额。
- 成交数量；
- 成交人数；
- 成交金额；
- 成交件单价=成交金额/成交数量；
- 成交客单价=成交金额/成交人数；
- 成交人数转化率=成交人数/下单人数；
- 成交订单转化率=成交数量/下单数量。

---

### 请简要描述一下什么是用户画像？用户画像通常包括哪些数据？

**用户画像就是人的数据标签**。这些标签是基于用户的日常行为信息、兴趣爱好、交易数据以及社会属性计算出来的模型，**多个标签的组合**就形成了用户画像。

用户画像包括 3 类数据：

- 用户基本数据：包含性别、年龄、职业和职业地域等数据。
- 电商行为数据：包含搜索、访问时长、加购、活跃度等行为数据。
- 电商交易数据：包含客单价、用户的下单量、下单金额、下单频次等交易数据。

---

### 请简述一下用户下订单路径，并且说明一下在各个环节涉及到哪些数据

1. 用户下订单路径：搜索/点击 → 商品详情页 → 直接购买/加入购物车 → 结算页 → 支付。
2. 涉及到的数据： 流量数据，商品数据，订单/订单商品数据，优惠/营销数据，支付数据。

---

### 请讲一下电商业务架构的核心模块、并简述一下电商业务系统的核心流程

(1)核心模块：电商业务包括三个主要实体，即供应商、电商平台、消费者。

(2)核心流程：一件商品卖给消费者需要经历的环节非常多，进行抽象后，可以将自营电商业务划分为以下 4 个核心部分，分别是：从供应商处采购产品，采购产品入仓存储管理，商品上架到电商平台销售，根据销售订单进行履约配送。

---

### 请说一下你在做交易数据过程中核心用到的数据表有哪些？

- 订单表（订单号、创建时间、用户名、订单总额、应付总额、运费金额、优惠券抵扣金额、支付方式）
- 订单项表（商品分类 id、商品 sku 编号、商品 sku 名字、商品 sku 价格、商品购买数量）
- 支付信息表（订单号、订单 id、交易流水号、支付总金额、支付状态、创建时间、确认时间）
- 退款信息表（退款 id、退款订单 id、退款金额、退款交易流水号、退款状态、退款渠道、退款信息）

---

### 介绍一下项目的业务背景和技术背景，项目中核心的业务过程、项目整体架构，并对每个主题域的数据建设做简要说明

**业务背景：**

1. 为管理层提供公司运营数据，支持业务决策。
2. 为业务运营人员提供数据支撑、可视化看板，优化日常运营策略。
3. 为商家提供运营动作效果数据，支撑商家日常的店铺运营

---

**技术背景：** 各个主题域建设的背景可以这样回答

1. 用户主题建设：以平台增长业务团队当前对用户主题数据的需求为契机，完善底层和应用层的用户数据建设，满足在业务侧在不同场景下的用数需求。这里主要涉及 dws、ads 层的建设。
2. 商品主题建设：由于历史原因，公司存在两套商品系统，老系统最后会合并到新系统里面去，但是在数据层面，需要同时兼容处理两套商品数据；将散落在各个地方的商品数据进行整合，统一构建商品主题的维表，在公司层面数据的一致性、准确性会得到保障。
3. 商家主题建设：以商家运营业务团队当前对用户访问商家浏览数据的需求为契机，建设用户访问商品的流量数据、构建公司级别的统一商户数据，主要是为 B 端的商家用户提供业务运营数据。这里主要涉及 ads 层的建设，数据加工完成后会回流到商家后台系统。
4. 交易数据建设：数据侧需要将订单下单、支付、退款等多个流程的数据整合起来，形成完整的交易数据体系；交易数据需要进行通用性地建设，用来服务于其他主题域、支持跨域数据的建设。
5. 营销数据建设：数据侧需要对优惠券主题数据进行建设，满足业务方的日常用数需求；优惠券数据与交易数据密切相关，建设时会引用订单数据。

---

**业务过程：**

把注册 → 流量 → 交易转化(浏览商品-加购-下单-支付-退款) → 复购的流程讲清楚

---

**整体架构：**

项目中涉及的核心表 50 个，数仓的建设遵循 onedata 的分层架构，ods → dwd → dws → ads，主要分为四层，其中 ods 层 17 个，dwd 层 7 个，dim 层 8 个，dws 层 9 个，ads 层 9 个。每一层具体存储的数据可以进行简要阐述。

---

### 请结合用户或者交易主题域的数据建设情况，阐述一下维度建模的具体流程

以用户主题域为例：其涉及的核心流程包括：用户登录 → 用户操作(浏览-收藏-加购、购买) → 用户流失。

而对应我们的维度建模流程，数据域建设时的具体流程如下：

(1)**需求搜集**：主要是用户增长团队、商家运营团队对用户行为数据的需求。

(2)**业务过程**：用户登录 APP 后，浏览相关的商品、收藏或者加入购物车、最后产生购买行为。

(3)**声明粒度**：这里涉及了 `日期*用户粒度的行为统计数据、日期*用户*商品粒度` 的浏览统计数据。

(4)**确定维度和事实**：这里涉及的主要维度包括日期、用户、商品，主要的事实（指标）包括浏览人数&次数、收藏人数&次数、加购人数&次数、购买人数&次数、流失率等。

---

### 请结合商品主题域的数据建设情况，阐述一下你对维表建设的思路

核心思路是：**选择维度 → 确认主维表 → 确认相关维表 → 确认维度表字段**。接下来举个例子：

比如选择 sku 商品维度，选择主维表为商品信息表，然后确定相关维表，比如品牌信息表、销售属性表，这两个表分别通过商品的品牌 ID、商品 ID 关联到主维表，从相关维表里面获取到品牌名称、商品的销售属性等字段，达到扩充主维表的目的，最终得到一个字段信息非常丰富的商品维度表(是个宽表)。
