# 数仓

## 数据库 VS 数据仓库

**数据库：**

数据库是面向业务的处理系统，它是针对具体业务在数据库联机的日常操作，通常对记录进行查询、修改。用户较为关心操作的响应时间、数据的安全性、完整性和并发支持的用户数等问题。传统的数据库系统作为数据管理的主要手段，主要用于操作型处理，也被称为**联机事务处理 OLTP**。

**数据仓库：**

面向主题的、集成的、非易失的且随时间变化的**数据集合**。

数据仓库一般**针对某些主题的历史数据进行分析**，支持管理决策，又被称为**联机分析处理 OLAP**。

!!! note "区别"

    - 数据库是面向事务的设计，数据仓库是面向主题设计的。
    - 数据库一般存储业务数据，数据仓库存储的一般是历史数据。
    - 数据库设计是尽量避免冗余，常采用符合范式规范来设计。数据仓库设计关注数据整合、分析、处理性能，有意引入冗余，采用反范式设计。
    - 数据库主要操作是随机读写，数据仓库是为分析数据而设计，主要操作是批量读写。

|          |         数据库         |         数据仓库         |
| :------: | :--------------------: | :----------------------: |
|   面向   |          事务          |           分析           |
| 数据类型 |       细节、业务       |    综合、清洗过的数据    |
| 数据特点 |     当前的、最新的     |    历史的、跨时间维护    |
|   目的   |        日常操作        |  长期信息需求、决策支持  |
| 设计模型 | 基于 ER 模型，面向应用 | 星型、雪花模型，面向主题 |
|   操作   |         读、写         |         大多为读         |
| 数据规模 |        GB 到 TB        |          >= TB           |

数据库核心作用是存储和查找业务数据，利用行式存储、索引，不能存储海量数据；数据仓库核心作用是分析数据，利用列式存储、分区、分桶等技术，可以存储海量数据。

---

## OLTP & OLAP

OLTP 系统通常面向的主要数据操作是随机读写，主要采用**满足 3NF 的实体关系模型**存储数据，从而**在事务处理中解决数据的冗余和一致性问题**。而 OLAP 系统面向的主要数据操作是批量读写，事务处理中的一致性不是 OLAP 所主要关注的，其主要**关注数据的整合，以及在一次性的复杂大数据查询和处理中的性能**，因此它需要采用一些不同的数据建模方法。

---

## 数据仓库的特点

- 面向主题的：数据仓库的数据是面向主题的，每个主题都有对应的业务需求，如电商数仓中常见的主题有商品、用户、交易等。
- 集成的：数据仓库的数据是从多个数据源中集成的，经过清洗、提取、转换、加载等过程。
- 非易失的：数据仓库中的数据以查询为主，修改和删除操作很少。
- 随时间变化的：数据仓库中的保存了历史数据，可以反应数据的历史变化，以指导决策。

---

## 建设数仓的目的/意义

- 数据仓库可以保留大量历史数据，反应数据的历史变化，以指导决策。
- 可以减轻业务数据库的存储和计算压力。
- 能够将多个数据源的数据进行整合，提供一个统一的数据视图。
- 能够将多个数据源的数据进行清洗、转换、统一，提高数据质量。
- 利用分层架构，能够快速查询大量已经整合的数据，减少重复开发。

---

## 数仓分层的意义

1. **清晰数据结构**：每一个数据分层都有**对应的作用域**，在使用数据的时候能更方便的定位和理解。

2. **数据血缘追踪**：提供给业务人员或下游系统的数据服务时都是目标数据，目标数据的数据来源一般都来自于多张表数据。若出现目标数据异常时，**清晰的血缘关系可以快速定位问题所在**。而且，血缘管理也是元数据管理重要的一部分。

3. **减少重复开发**：数据的逐层加工原则，下层包含了上层数据加工所需要的全量数据，这样的加工方式避免了每个数据开发人员都重新从源系统抽取数据进行加工。

4. **数据关系条理化**：源系统间存在复杂的数据关系，数据仓库会对相同主题的数据进行统一建模，**把复杂的数据关系梳理成条理清晰的数据模型**。

5. **屏蔽原始数据的影响**：数据的逐层加工原则，上层的数据都由下一层的数据加工获取，不允许跳级取数。而原始数据位于数仓的最底层，离应用层数据还有多层的数据加工，所以加工应用层数据的过程中就会**把原始数据的变更消除掉，保持应用层的稳定性**。

---

## Inmon、Kimball 数仓架构

**Inmon 架构：**

Inmon 架构是**自上而下**地建构数据仓库，强调标准化的数据模型和**范式建模**，其核心思想是数仓分层。Inmon 模型包括三层：高层模型、中间层模型和底层模型。

**Kimball 架构：**

Kimball 架构是**自下而上**地构建数据仓库，根据业务需求找到数据指标，再基于指标设计数据模型，从数据源到数据集市再到数据仓库。其核心思想是**维度建模**，通过星型模型或雪花模型构建维度数据仓库。

**区别：**

- Inmon 架构采用范式建模，模型设计会更规范，冗余更少，但是模型设计会更复杂。
- Kimball 架构采用维度建模，数据模型会更灵活，但是维护的成本更高。

---

## 数仓建模流程

- 了解业务需求
- 逻辑设计，确定数据来源和数据之间的关系
- 物理设计，建表、设置分区等
- 数据处理，ETL
- 搭建数仓、使用数据
- 数据维护
- 数据质量保障

---

## 三范式

!!! note "1NF"

    **确保表中的每列是原子、不可再分的。**

!!! note "2NF"

    在满足 1NF 的情况下，**不能存在部分依赖。**即非主键字段必须**完全依赖**于主键，而不能依赖于主键的一部分。

考虑一个订单明细表：`OrderDetail(OrderID，ProductID，UnitPrice，Discount，Quantity，ProductName)`。

因为我们知道在一个订单中可以订购多种产品，所以单单一个 OrderID 是不足以成为主键的，主键应该是 `(OrderID，ProductID)`。显而易见 `Discount` 和 `Quantity` 完全依赖于主键 `(OrderID，ProductID)`，而 `UnitPrice` 和 `ProductName` 只依赖于 `ProductID`。所以 OrderDetail 表不符合 2NF。不符合 2NF 的设计容易产生冗余数据。

可以把 OrderDetail 表拆分为 `OrderDetail(OrderID，ProductID，Discount，Quantity)` 和 `Product(ProductID，UnitPrice，ProductName)` 来消除原订单表中 `UnitPrice` 和 `ProductName` 多次重复的情况。

!!! note "3NF"

    在满足 2NF 的情况下，**不能存在传递依赖。** 3NF 是对字段冗余性的约束，要求任何字段不能由其他字段派生出来，它要求字段没有冗余，即不存在传递依赖。

考虑一个订单表 `Order(OrderID，OrderDate，CustomerID，CustomerName，CustomerAddr，CustomerCity)` 主键是 `(OrderID)`。

其中 `OrderDate, CustomerID, CustomerName, CustomerAddr, CustomerCity` 等非主键列都完全依赖于主键 `(OrderID)`，所以符合 2NF。不过问题是 `CustomerName, CustomerAddr, CustomerCity` 直接依赖的是 `CustomerID`（非主键列），而不是直接依赖于主键，它是通过传递才依赖于主键，所以不符合 3NF。

通过拆分 Order 为 `Order(OrderID，OrderDate，CustomerID)` 和 `Customer(CustomerID，CustomerName，CustomerAddr，CustomerCity)` 从而达到 3NF。

**第二范式（2NF）和第三范式（3NF）的概念很容易混淆，区分它们的关键点在于，2NF：非主键列是否完全依赖于主键，还是依赖于主键的一部分；3NF：非主键列是直接依赖于主键，还是直接依赖于非主键列。**

!!! note "反范式化"

    降低范式就是增加字段，允许冗余，达到以空间换时间的目的。

没有冗余的数据库设计可以做到。但是，没有冗余的数据库未必是最好的数据库，有时为了提高运行效率，就必须降低范式标准，适当保留冗余数据。

如订单表，“金额”这个字段的存在，表明该表的设计不满足第三范式，因为“金额”可以由“单价”乘以“数量”得到，说明“金额”是冗余字段。但是，增加“金额”这个冗余字段，可以提高查询统计的速度，这就是以空间换时间的作法。

!!! summary "范式化与反范式化"

    范式化优点：

    - 可以尽量减少数据冗余
    - 范式化的更新操作比反范式化更快
    - 范式化的表通常比反范式化更小


    范式化缺点：

    - 对于查询需要对多个表进行关联，导致性能降低
    - 更难进行索引优化


    反范式化优点：

    - 可以减少表的关联
    - 可以更好地进行索引优化


    反范式化缺点：

    - 存在数据冗余及数据维护异常
    - 对数据的修改需要更多的成本

---

## 你用过哪些逆范式设计

---

## 维度建模

维度模型是一种趋向于支持最终用户对数据仓库进行查询的设计技术，**是围绕性能和易理解性构建的**。尽管关系模型对于事务处理系统表现非常出色，但它并不是面向最终用户的。

**事实**和**维度**是两个维度模型中的核心概念。事实表示对业务数据的度量，而维度是观察数据的角度。事实通常是数字类型的，可以进行聚合和计算，而维度通常是一组层次关系或描述信息，用来定义事实。

维度模型设计期间主要涉及 4 个主要的过程：

1. 选择业务过程
2. 声明粒度
3. 确认维度
4. 确认事实

例如：进行一场游戏对局：

- 业务过程：匹配、对局、结算
- 粒度：每场对局的每个玩家
- 维度：服务器、游戏模式等（可供分析的角度）
- 事实/度量：对局时长等（可用于分析的数据）

---

## 维度建模特点

**易理解：**

相对于规范化的关系模型，维度模型容易理解且更直观。在维度模型中，信息按业务种类或维度进行分组，这会提高信息的可读性，也方便了对于数据含义的解释。简化的模型也让系统以更为高效的方式访问数据库。关系模型中，数据被分布到多个离散的实体中，对于一个简单的业务流程，可能需要很多表联合在一起才能表示。

**高性能：**

维度模型更倾向于非规范化，因为这样可以优化查询的性能。规范化的实质是减少数据冗余，以优化事务处理或数据更新的性能。

**可扩展：**

维度模型是可扩展的。由于维度模型允许数据冗余，因此当向一个维度表或事实表中添加字段时，不会像关系模型那样产生巨大的影响，带来的结果就是更容易容纳不可预料的新增数据。这种新增可以是单纯地向表中增加新的数据行而不改变表结构，也可以是在现有表上增加新的属性。基于数据仓库的查询和应用不需要过多改变就能适应表结构的变化。老的查询和应用会维续工作而不会产生错误的结果。但是对于规范化的关系模模型，由于表之间存在复杂的依赖关系，改变表结构前一定要仔细考虑。

---

## 星型模型 & 雪花模型

**星型模型：**

**星型模式由事实表和维度表组成，一个星型模式中可以有一个或多个事实表，每个事实表引用任意数量的维表。**

![](https://raw.githubusercontent.com/MXJULY/image/main/img/202312281918072.png)

星型模式是**反范式化(denormalized)**的，**优点**是设计和实现起来比较简单，查询性能也比较高（join 的数量较少）。但是，星型模式的**缺点**是数据存储空间较大；而且，由于是非规范化的，数据的更新操作会更困难。星型模式的另一个缺点是对于分析需求来说不够灵活。它更偏重于为特定目的建造数据视图，因此实际上很难进行全面的数据分析。

**雪花模型：**

雪花模型是星型模型的扩展，**雪花模型是在星型模型的基础上，将维度表进一步范式化(normalized)**，即将维度表中的某些字段单独成表，这些字段和维度表的主键构成主外键关系。

![](https://raw.githubusercontent.com/MXJULY/image/main/img/202312281919853.png)

雪花模型的特点是**维度表的规范化程度更高**，因此**减少了数据冗余、节省了存储空间**，但是不可避免地增加了表的数量，因此**查询性能会有所下降**。

**星型 VS 雪花模型**

| 属性           | 星型模型 | 雪花模型           |
| :------------- | :------- | :----------------- |
| 数据总量       | 多       | 少                 |
| 可读性         | 高       | 低                 |
| 表个数         | 少       | 多                 |
| 查询速度       | 高       | 低                 |
| 数据冗余       | 多       | 少                 |
| 对事实表的情况 | 增加宽度 | 字段比较少，冗余低 |
| 拓展性         | 差       | 好                 |

**星型模型因为数据的冗余所以很多统计查询不需要做外部的连接，因此一般情况下效率比雪花型模型要高**。星型结构不用考虑很多范式化的因素，设计与实现都比较简单。

雪花型模型由于去除了冗余，有些统计就需要通过表的联接才能产生，所以效率不一定有星型模型高。范式化也是一种比较复杂的过程，相应的数据库结构设计、数据的 ETL、以及后期的维护都要复杂一些。**因此在冗余可以接受的前提下，实际运用中星型模型使用更多，也更有效率**。

---

## 事实表

- **事务事实表**：记录事务层面的事实，记录最原子的数据，粒度通常为每个事务记录一条数据
- **周期快照事实表**：以周期性的时间间隔来记录事实，如库存日快照表，粒度是一个周期性的时间间隔内的事务记录一条数据
- **累计快照事实表**：记录不确定周期的数据，通常覆盖一个事务的生命周期，记录一些关键时间点，如订单累计快照事实表会记录付款日期、发货日期、收货日期等。

|            |       事务事实表       |          周期快照事实表          |            累计快照事实表            |
| ---------- | :--------------------: | :------------------------------: | :----------------------------------: |
| 时间       |     离散事务时间点     | 以有规律的、可预测的间隔产生快照 | 用于时间跨度不确定的不断变化的工作流 |
| 日期维度   |        事务日期        |             快照日期             |      相关业务过程涉及的多个日期      |
| 粒度       | 每行代表实体的一个事务 |   每行代表某时间周期的一个实体   |      每行代表一个实体的生命周期      |
| 事实       |        事务事实        |             累积事实             |    相关业务过程事实和时间间隔事实    |
| 事实表加载 |          插入          |               插入               |              插入与更新              |
| 事实表更新 |         不更新         |              不更新              |          业务过程变更时更新          |

---

## 如何设计事实表

---

## 如何设计维度表

1. **选择或者新建一个维度**，通过之前总线矩阵的构建掌握了目前数仓架构中的维度。
2. **确定主维表**。此处主维表一般是 ODS 表，直接与业务系统同步。
3. **确定相关维表**。数仓是业务源系统的数据整合，不同业务系统或者同一业务系统中的表之间存在关联性。跟据对业务的梳理，我们可以确认哪些表和主维表存在关联关系，并选择其中的某些表用于生成维度属性。
4. **确定维度属性**。本步骤分为两阶段，第一阶段是从主维表中选择维度属性或生成新的维度属性；第二阶段是从相关维表中选择维度属性或生成新的维度属性。

以商品维度举例：

1. 选择维度：商品维度
2. 确定主维表：商品表
3. 确定相关维表：商品分类表、商品品牌表、SPU 表等
4. 确定维度属性：商品表中的商品 ID、商品名称、商品价格等；商品分类表中的商品分类 ID、商品分类名称等；商品品牌表中的商品品牌 ID、商品品牌名称等；SPU 表中的商品 SPU ID、商品 SPU 名称等。

---

## 如何处理缓慢变化维度

- 保留或重写（适用于不需要考虑历史变化的维度，优点是简化 ETL，节省存储空间）
- 增加新行（维度变化时增加新行，并通过生效时间和失效时间来标识数据，维度值变化前的事实和过去的维度值关联，维度值变化后的事实和当前的维度值关联）
- 增加新列（增加新列，维护修改之前的维度值和修改之后的维度值，适合变化频率很低的维度属性）
- 快照存储（每次更新维护一个全量的历史快照表，会占用大量的存储空间）
- 拉链表存储（通过维护生效时间和失效时间来标识新数据还是旧数据）

---

## 数据质量包括哪些方面

1. **完整性**：是指数据的记录和信息是否完整，是否存在缺失的情况。
2. **准确性**：是指数据中记录的信息和数据是否准确，是否存在异常或者错误的信息。
3. **一致性**：一般体现在跨度很大的数据仓库体系中，比如阿里巴巴数据仓库，内部有很多业务数据仓库分支，对于同一份数据，必须保证一致性。
4. **时效性**：指的是保障数据能够及时产出。

---

## DQC

DQC：Data Quality Check，数据质量检查，用于在数据处理的过程中检查数据质量，可以通过设定规则对数据处理过程中的数据进行监控和告警。常用于检查主键是否唯一，检查空值，数据类型和精度等。

DQC 是与平台的任务调度系统耦合的，以任务为单位，可以配置数据质量检查的任务。

有一些常用的模板：比如跟前一天的表进行比较，数据波动等；但是不能配置太多，影响作业的产出。有强规则（中断执行）、弱规则（告警）。

配置数据质量监控时，需要关注以下几个方面：

1. **完整性**：确保关键字段值不为空，如 matchId 等。
2. **准确性**：确保数据符合业务规则和约束条件，边界值等，如服务器只能出现几个固定的枚举值、KDA 是正整数等。
3. **一致性**：确保数据在不同表之间保持一致，如用户表和订单表中的用户信息应保持一致。
4. **时效性**：确保数据及时更新，如统计表应按照预定的时间周期进行更新。SLA 告警。

另外还可以进行测试、给业务方参考等。

其中一致性是需要额外关注的。

---

## SLA

SLA：Service Level Agreement，在数仓场景中通常指最晚出数时间，SLA 可以通过上游任务的历史执行时间推测一个预计的执行时间，以此来预估一个任务的最晚的产出时间。主要注重数据服务的时效性和稳定性。

- 有任务的重要性等级 p0, p1, p2 等。

- 如何保证？有基线的概念，一级二级三级，挂哪级基线就是什么等级，这会在资源紧张时影响执行优先级。如果任务会过线，会告警。

- 设置基线：起名字、设置节点、设置时间、设置告警方式

---

## 你们公司如何做数据任务监控/保证数据质量？

- 数据的时效性通过 SLA 预估最晚出数时间，任务过线会告警，优先分配资源给高优先级任务。
- 数据的完整性和准确性通过 DQC 进行数据质量检查，对异常数据进行监控和告警，包括主键是否唯一、检查空值、数据类型等。
- 数据的一致性则是需要考虑

---

## 什么是总线矩阵

总线矩阵：是**对业务过程、一致性维度的划分**，主要呈现的是两者之间的关系。

构建总线矩阵：核心需要做两件事情：

1. 明确每个数据域下有哪些业务过程。
2. 业务过程与哪些维度相关，并通过总线矩阵定义每个数据域下的业务过程和维度。

![](https://raw.githubusercontent.com/MXJULY/image/main/img/202401201946858.png)

---

## 指标相关

[原子、派生与复合：探索指标产品管理模型的核心思想](https://www.woshipm.com/it/5832013.html)

---

## 主题域如何划分
