## ZooKeeper 概述

在雅虎内部很多大型系统基本都需要依赖一个系统来进行分布式协调，但是这些系统往往都存在分布式单点问题。所以，雅虎的开发人员就试图开发一个**通用的无单点问题的分布式协调框架**，以便让开发人员将精力集中在处理业务逻辑上。

**ZooKeeper 为分布式应用提供了高效且可靠的分布式协调服务，提供了诸如统一命名服务、配置管理和分布式锁等分布式的基础服务。**

ZooKeeper 的设计目标是将那些**复杂且容易出错的分布式一致性服务封装起来**，构成一个高效可靠的**原语集**，并以一系列简单易用的接口提供给用户使用。

简单概括起来就是：**Zookeeper 是一个分布式协调服务的开源框架，主要用来解决分布式系统的一致性问题。**

官网介绍：

ZooKeeper 允许分布式进程通过共享的层次化数据寄存器命名空间（我们称之为 **znodes**）来协调彼此的操作，类似于文件系统。与普通文件系统不同，ZooKeeper 为其客户端提供高吞吐量、低延迟、高可用性的、严格有序的对 znodes 的访问。

- ZooKeeper 的性能特点使其可以在大型分布式系统中使用。
- 可靠性方面的特性防止它成为大型系统中的单点故障。
- 其严格的排序允许在客户端实现复杂的同步原语。

ZooKeeper 提供的命名空间与标准文件系统非常相似。一个名称是由一系列由斜杠（"/"）分隔的路径元素组成。ZooKeeper 命名空间中的每个 znode 都通过路径进行标识。每个 znode 都有一个父节点，其路径是 znode 路径的前缀，路径元素减少一个；唯一的例外是根节点（"/"）没有父节点。与标准文件系统类似，如果一个 znode 有子节点，则不能删除该 znode。

ZooKeeper 和标准文件系统之间的主要区别在于每个 znode 可以关联数据（每个文件也可以是目录，反之亦然），并且 znode 对其可以存储的数据量有限制。ZooKeeper 设计用于存储协调数据，如状态信息、配置、位置信息等。这种元信息通常以千字节甚至字节为单位进行衡量。ZooKeeper 内置了 1M 的合理性检查，以防止其被用作大型数据存储，但通常用于存储较小的数据片段。

该服务本身在组成服务的一组机器上进行复制。这些机器在持久存储中维护着数据树的内存映像、事务日志和快照。由于数据保存在内存中，ZooKeeper 能够实现非常高的吞吐量和低延迟。内存数据库的缺点是 ZooKeeper 可以管理的数据库大小受到内存的限制。这个限制进一步说明了需要保持存储在 znodes 中的数据量较小的原因。

组成 ZooKeeper 服务的服务器必须彼此知道。只要大多数服务器可用，ZooKeeper 服务就会可用。客户端也必须知道服务器列表。客户端使用该服务器列表创建一个与 ZooKeeper 服务的连接。

客户端只连接到单个 ZooKeeper 服务器。客户端通过维护一个 TCP 连接发送请求、接收响应、获取监视事件和发送心跳。如果与服务器的 TCP 连接中断，客户端将连接到另一个服务器。当客户端首次连接到 ZooKeeper 服务时，第一个 ZooKeeper 服务器将为客户端建立一个会话。如果客户端需要连接到另一个服务器，该会话将在新服务器上重新建立。

由 ZooKeeper 客户端发送的读取请求在连接的 ZooKeeper 服务器上进行本地处理。如果读取请求在 znode 上注册了监视，该监视也在 ZooKeeper 服务器上进行本地跟踪。写入请求将转发到其他 ZooKeeper 服务器，并在生成响应之前进行共识。同步请求也会转发到另一个服务器，但实际上不会经过共识。因此，读取请求的吞吐量随着服务器数量的增加而扩展，而写入请求的吞吐量随着服务器数量的增加而降低。

对于 ZooKeeper 来说，顺序非常重要，几乎可以说是强迫症。所有更新都是完全有序的。实际上，ZooKeeper 会为每个更新分配一个反映该顺序的编号，我们称之为 zxid（ZooKeeper 事务 ID）。每个更新都有一个唯一的 zxid。读取请求（和监视）与更新有序。读取响应将带有由服务读取的服务器上处理的最后一个 zxid 的时间戳。

### ZooKeeper 中的角色

![](https://raw.githubusercontent.com/MXJULY/image/main/img/202309120003095.png)

1.	领导者（leader）：负责进行投票的发起和决议，更新系统状态。事务请求（写操作）的唯一调度和处理者，保证集群事务处理的顺序性；集群内部各个服务器的调度者。

2.	跟随者（follower）：用于接收客户端请求并给客户端返回结果，本质是处理客户端非事务（读操作）请求，转发事务请求给 Leader；在选主过程中进行投票。

3.	观察者（observer）：zk3.3.0 版本以后引入的一个服务器角色。可以接受客户端连接，将写请求转发给 leader，但是 observer 不参加投票的过程，只是为了扩展系统，提高读取的速度。

### ZooKeeper 数据结构

**Zookeeper 维护一个类似文件系统的数据结构**。ZooKeeper 的数据模型，在结构上和类 Unix 文件系统的非常相似，拥有一个层次的命名空间，都是采用树形层次结构。

本质上 Zookeeper 之所以能够分布式一致性问题，都是靠两个模块：文件系统和通知机制。

**所以简单来说 ZooKeeper = 文件系统 + 注册通知机制。**

![](https://raw.githubusercontent.com/MXJULY/image/main/img/202309120016652.png)

每个子目录项如 NameService 都被称作为 znode，和文件系统一样，我们能够自由的增加、删除 znode，在一个 znode 下增加、删除子 znode，**唯一的不同在于 znode 是可以存储数据的 (Znode 存储数据大小有限制，一般小于 1M)**。znode 是一个跟 Unix 文件系统路径相似的节点，可以往这个节点存储或获取数据。

**ZooKeeper 可以理解成一个高可用的分布式文件存储系统**（只是这个文件系统中没有文件和目录。而是统一使用节点 znode，它即可当做容器存放数据，也可以当做子 znode 的父目录）提供基于类似于文件系统的目录树方式的数据存储，并且可以对树中的节点进行有效管理，从而**用来维护和监控你存储的数据的状态变化**。

**通过监控这些数据状态的变化，从而可以达到基于数据的集群管理。诸如：统一命名服务、分布式配置管理、分布式消息队列、分布式锁、分布式协调等功能。**

ZooKeeper 中的 znode 有 4 种：

- `PERSISTENT` - 持久化目录节点：客户端与 zookeeper 断开连接后，该节点依旧存在

- `PERSISTENT_SEQUENTIAL` - 持久化顺序编号目录节点：客户端与 zookeeper 断开连接后，该节点依旧存在，只是 Zookeeper 给该节点名称进行顺序编号

- `EPHEMERAL` - 临时目录节点：客户端与 zookeeper 断开连接后，该节点被删除

- `EPHEMERAL_SEQUENTIAL` - 临时顺序编号目录节点：客户端与 zookeeper 断开连接后，该节点被删除，只是 Zookeeper 给该节点名称进行顺序编号

### ZooKeeper 注册通知机制

本质很简单，**客户端注册监听它关心的目录节点 znode，当目录节点发生变化（数据改变、被删除、子目录节点增加删除）时，ZooKeeper 会通知客户端**。

详细解释版：

**ZooKeeper 提供了一种注册和监听机制，用于实现分布式系统中的事件通知和协调。这个机制允许客户端在 ZooKeeper 上的 znode 节点上注册监听器，并在节点的状态发生变化时接收通知。**

注册监听器的过程包括以下几个步骤：

1. 创建一个 ZooKeeper 客户端连接到 ZooKeeper 服务集群。

2. 使用客户端连接，创建一个 znode 节点或获取现有的 znode 节点。

3. 在 znode 节点上注册一个监听器，指定监听的类型（例如，数据变化、子节点变化等）。

4. 当指定的事件类型在 znode 节点上发生变化时，ZooKeeper 将通知相关的监听器。

监听器通常以**回调函数**的形式实现。当监听的事件发生时，ZooKeeper 将调用注册的监听器的回调函数，将相关的事件信息传递给客户端应用程序。客户端应用程序可以根据接收到的通知进行相应的处理，例如更新数据、重新注册监听器等。

ZooKeeper 的注册监听机制具有以下特点：

1. 实时性：一旦注册了监听器，当 znode 节点上的状态发生变化时，监听器将立即收到通知。这使得分布式系统能够实时响应节点的变化。

2. 有序性：ZooKeeper 保证相同类型的事件按照顺序传递给监听器。这样客户端应用程序就可以按照事件的顺序进行处理，确保一致性和可靠性。

3. 可靠性：ZooKeeper 会在客户端和服务器之间建立持久的 TCP 连接，并通过心跳机制确保连接的可靠性。即使在网络故障或服务器故障的情况下，ZooKeeper 也能够保证监听器能够接收到事件通知。

通过注册监听器，ZooKeeper 提供了一种可靠的机制，用于分布式系统中的事件触发和协调，使得系统中的各个组件能够及时、有序地响应和处理节点的变化。这在实现分布式锁、分布式队列等场景中非常有用。

### ZooKeeper 的应用场景

#### 一致性配置管理

数据发布/订阅系统,需要发布者将数据发布到 ZooKeeper 的节点上，供订阅者进行数据订阅，进而达到动态获取数据的目的，实现配置信息的集中式管理和数据的动态更新。

**发布/订阅一般有两种设计模式：推模式和拉模式，服务端主动将数据更新发送给所有订阅的客户端称为推 push 模式，客户端主动请求获取最新数据称为拉 pull 模式。**

**Zookeeper 采用了推拉相结合的模式**，客户端向服务端注册自己需要关注的节点，一旦该节点数据发生变更，那么服务端就会向相应的客户端推送 **Watcher 事件通知**，客户端接收到此通知后，**主动到服务端获取最新的数据**。

![](https://raw.githubusercontent.com/MXJULY/image/main/img/202309120051869.png)

举个例子：有时候需要获取一些公共的配置，比如数据库连接信息等，并且偶然可能需要更新配置。如果我们的服务器有 N 多台的话，那修改起来会特别的麻烦，并且还需要重新启动。这里 Zookeeper 就可以很方便的实现类似的功能。

那就是把这些配置全部放到 zookeeper 上去，保存在 Zookeeper 的某个目录节点中，然后所有相关应用程序对这个目录节点进行监听，一旦配置信息发生变化，每个应用程序就会收到 Zookeeper 的通知，然后从 Zookeeper 获取新的配置信息应用到系统中就好。

#### 分布式锁

有了 zookeeper 的一致性文件系统，锁的问题变得容易。**锁服务可以分为两类，一个是保持独占，另一个是控制时序。**

对于第一类，所谓保持独占锁，就是所有试图来获取这个锁的客户端，最终只有一个可以成功获得这把锁。我们将 zookeeper 上的一个 znode 看作是一把锁，通过 create znode 的方式来实现。所有客户端都去创建 `/distribute_lock` 节点，最终成功创建的那个客户端也即拥有了这把锁。用完删除掉自己创建的 `distribute_lock` 节点就释放出锁。

对于第二类， 控制时序，就是所有试图来获取这个锁的客户端，最终都是会被安排执行，只是有个**全局时序**了。做法和上面基本类似，只是这里 `/distribute_lock` 已经预先存在，客户端在它下面创建**临时有序节点**（这个可以通过节点的属性控制：`CreateMode.EPHEMERAL_SEQUENTIAL` 来指定）。ZooKeeper 的父节点（`/distribute_lock`）维持一份 sequence，保证子节点创建的时序性，从而也形成了每个客户端的全局时序。

1.	由于同一节点下子节点名称不能相同，所以只要在某个节点下创建 Znode，创建成功即表明加锁成功。注册监听器监听此 Znode，只要删除此 Znode 就通知其他客户端来加锁。

2.	创建临时顺序节点：在某个节点下创建节点，来一个请求则创建一个节点，由于是顺序的，所以序号最小的获得锁，当释放锁时，通知下一序号获得锁。

![](https://raw.githubusercontent.com/MXJULY/image/main/img/202309120100570.png)

#### 分布式队列

在日常使用中，特别是像生产者消费者模式中，经常会使用 BlockingQueue 来充当缓冲区的角色。但是在分布式系统中这种方式就不能使用 BlockingQueue 来实现了，但是 Zookeeper 可以实现。

1. 首先利用 Zookeeper 中临时顺序节点的特点

2. 当生产者创建节点生产时，需要判断父节点下临时顺序子节点的个数，如果达到了上限，则阻塞等待；如果没有达到，就创建节点。

3. 当消费者获取节点时，如果父节点中不存在临时顺序子节点，则阻塞等待；如果有子节点，则获取执行自己的业务，执行完毕后删除该节点即可。

4. 获取时获取最小值，保证 FIFO 特性。

#### 负载均衡

如果是一个集群，那么他就会有多台主机。当服务调用方调用服务时，就可以根据特定的均衡负载算法来实现对服务的调用（调用前需要监听/service/serviceXXX 节点，以更新列表数据）

![](https://raw.githubusercontent.com/MXJULY/image/main/img/202309120103591.png)

#### 其他

其他如分布式协调，命名服务。比如命名服务也是分布式系统中比较常见的一类场景。其中较为常见的就是一些分布式服务框架中的服务地址列表。通过调用 ZooKeeper 提供的创建节点的 API，能够很容易创建一个全局唯一的 path，这个 path 就可以作为一个名字。

阿里巴巴集团开源的分布式服务框架 Dubbo 中使用 ZooKeeper 来作为其命名服务，维护全局的服务地址列表。

### ZooKeeper 的运行模式

Zookeeper 有三种运行模式：单机模式、伪集群模式和集群模式。

## ZooKeeper 客户端命令操作

[ZooKeeper Getting Started Guide](https://zookeeper.apache.org/doc/current/zookeeperStarted.html)

```bash
bin/zkServer.sh start

# Connect with
bin/zkCli.sh -server 127.0.0.1:2181

# Commands
ls <path>
get <path>
set <path> 
delete <path>
```

```bash
ls <path> #列出path下所有子znode
ls2 <path> #查看path下所有子znode以及子znode的属性
create [-s] [-e] <path> <data> <acl>
#参数：-s 或-e 分别指定节点特性，顺序或临时节点，若不指定，则表示持久节点；acl 用来进行权限控制
get <path>
#与读取相关的命令有 ls 命令和 get 命令，ls 命令可以列出 Zookeeper 指定节点下的所有子节点，只能查看指定节点下的第一级的所有子节点；get 命令可以获取 Zookeeper 指定节点的数据内容和属性信息
```
