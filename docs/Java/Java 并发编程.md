## 什么是进程和线程？

- 进程是程序的一次执行过程，或一个运行中的程序。
- 进程是一个动态的过程：产生、存在和消亡的生命周期。

- 线程是属于进程的，是一个程序内部的一条执行路径。
- 线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。
- 同进程的多个线程共享进程的堆和方法区资源，但每个线程有自己的程序计数器、虚拟机栈和本地方法栈。

---

## 什么是并行和并发？

- 并行（Parallelism）：在同一时刻，有多个任务同时执行，并行是真正意义上的“同时执行”。
- 并发（Concurrency）：在同一时间段，有多个任务交替执行，而多个任务之间有可能还是串行的，只是宏观上感觉是同时执行。

最关键的区别是：多个任务是否是同时执行的。

---

## 为什么要使用多线程？/多线程有什么优点？

- 线程作为轻量级的进程，线程间的切换和调度成本远低于进程
- 充分利用多核 CPU 的运算能力
- 利用好多线程机制可以提高系统整体的并发能力和性能

缺点：

- 频繁的上下文切换
- 线程安全问题

---

## 什么时候需要使用多线程？

- 程序需要同时执行多个任务时，并行计算
- 程序需要实现一些等待的任务时，如用户输入、文件读取、网络操作等
- 需要一些后台运行的程序时，异步调用时

> 并发编程可能导致什么问题？

- 内存泄漏
- 死锁
- 线程安全问题

---

## 如何实现多线程？/创建线程的几种方式

通过继承 Thread 类来创建并启动线程的步骤如下：

1. 定义 Thread 类的子类，并重写该类的 `run()` 方法，该 `run()` 方法将作为线程执行体；
2. 创建 Thread 子类的实例，即创建了线程对象；
3. 调用线程对象的 `start()` 方法来启动该线程。

通过实现 Runnable 接口来创建并启动线程的步骤如下：

1. 定义 Runnable 接口的实现类，并实现该接口的 `run()` 方法，该 `run()` 方法将作为线程执行体；
2. 创建 Runnable 实现类的实例，并将其作为 Thread 的 target 来创建 Thread 对象，Thread 对象为线程对象；
3. 调用线程对象的 `start()` 方法来启动该线程。

通过实现 Callable 接口来创建并启动线程的步骤如下：

1. 创建 Callable 接口的实现类，并实现 `call()` 方法，该 `call()` 方法将作为线程执行体，且该 `call()` 方法有返回值，然后再创建 Callable 实现类的实例；
2. 使用 FutureTask 类来包装 Callable 对象，该 FutureTask 对象封装了该 Callable 对象的 `call()` 方法的返回值；
3. 使用 FutureTask 对象作为 Thread 对象的 target 创建并启动新线程；
4. 调用 FutureTask 对象的 `get()` 方法来获得子线程执行结束后的返回值。

实现 Runnable 接口和 Callable 接口有什么区别呢？

- Runnable 接口不会返回结果或抛出检查异常，但是 Callable 接口可以。
- 所以，如果任务不需要返回结果或抛出异常推荐使用 Runnable 接口。

---

## 线程的状态/生命周期

Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态：

- NEW: 初始状态，线程被创建出来但没有被调用 start() 。
- RUNNABLE: 运行状态，线程被调用了 start() 等待运行的状态。
- BLOCKED：阻塞状态，需要等待锁释放。
- WAITING：等待状态，表示该线程需要等待其他线程做出一些特定动作（通知或中断）。
- TIME_WAITING：超时等待状态，可以在指定的时间后自行返回而不是像 WAITING 那样一直等待。
- TERMINATED：终止状态，表示该线程已经运行完毕。

线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。

![](https://raw.githubusercontent.com/MXJULY/image/main/img/202309190614458.png)

---

## run() VS start()

简洁版：

- `run()`：封装线程执行的代码，直接调用相当于调用普通方法。
- `start()`：启动线程，然后由 JVM 调用此线程的 `run()` 方法。

详细版：

- `run()` 方法被称为线程执行体，它的方法体代表了线程需要完成的任务，而 `start()` 方法用来启动线程。调用 `start()` 方法启动线程时，系统会把该 `run()` 方法当成线程执行体来处理。

- 如果直接调用线程对象的 `run()` 方法，则 `run()` 方法立即就会被执行，而且在 `run()` 方法返回之前其他线程无法并发执行。

- 也就是说，如果直接调用线程对象的 `run()` 方法，系统把线程对象当成一个普通对象，而 `run()` 方法也是一个普通方法，而不是线程执行体。

---

## 什么是线程的上下文切换？

**线程在执行过程中会有自己的运行条件和状态（也称上下文）**，比如程序计数器，栈信息等。当出现如下情况的时候，线程会从占用 CPU 状态中退出：

- 主动让出 CPU，比如调用了 `sleep()`, `wait()` 等。
- 时间片用完，因为操作系统要防止一个线程或者进程长时间占用 CPU 导致其他线程或者进程饿死。
- 调用了阻塞类型的系统中断，比如请求 IO。
- 被终止或结束运行

这其中前三种都会发生线程切换，**线程切换意味着需要保存当前线程的上下文，留待线程下次占用 CPU 的时候恢复现场，并加载下一个将要占用 CPU 的线程上下文。**这就是所谓的上下文切换。

上下文切换是现代操作系统的基本功能，因其每次需要保存信息恢复信息，这将会占用 CPU，内存等系统资源进行处理，也就意味着效率会有一定损耗，如果频繁切换就会造成整体效率低下。

---

## 线程间通信有哪些方式？

线程间通信主要是为了解决线程同步和协作的问题。

- 共享变量
- 等待/通知机制（wait/notify）
- 消息队列（生产者消费者的阻塞队列）
- 信号量
- 条件变量等

---

## 什么是死锁？产生条件？如何预防？

死锁（Deadlock）：多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。

只有以下这四个条件都发生时才会出现死锁：

- **互斥**，共享资源 X 和 Y 只能被一个线程占用；
- **占有且等待**，线程 T1 已经取得共享资源 X，在等待共享资源 Y 的时候，不释放共享资源 X；
- **不可抢占**，其他线程不能强行抢占线程 T1 占有的资源；
- **循环等待**，线程 T1 等待线程 T2 占有的资源，线程 T2 等待线程 T1 占有的资源，就是循环等待。

反过来分析，也就是说只要我们破坏其中一个，就可以成功避免死锁的发生。

- 对于“占用且等待”这个条件，我们可以**一次性申请所有的资源**，这样就不存在等待了。
- 对于“不可抢占”这个条件，占用部分资源的线程进一步申请其他资源时，如果**申请不到，可以主动释放它占有的资源**，这样不可抢占这个条件就破坏掉了。
- 对于“循环等待”这个条件，可以靠**按序申请资源**来预防。所谓按序申请，是指资源是有线性顺序的，申请的时候可以先申请资源序号小的，再申请资源序号大的，这样线性化后自然就不存在循环了。
- 死锁检测：通过算法和方法检测系统中是否存在死锁。常见的死锁检测算法包括资源分配图（Resource Allocation Graph）和银行家算法（Banker's Algorithm）。这些算法通过分析资源的分配情况和线程的请求关系来确定是否存在循环等待的情况。

---

## 实现线程同步的方法

使用锁：

- 使用 synchronized 修饰方法或代码块
- 使用 ReentrantLock
- 使用 Semaphore
- 使用 CountdownLatch
- 使用 CyclicBarrier

无锁（适用于简单的更新共享变量的情况）：

- 使用 volatile + CAS
- 使用原子类，如 AtomicInteger

---

## 怎么理解线程安全问题？

线程安全和不安全是在多线程环境下对于**同一份数据的访问是否能够保证其正确性和一致性的描述。**

从**原子性、可见性、有序性**三方面考虑。

- 线程安全指的是在多线程环境下，对于同一份数据，不管有多少个线程同时访问，都能保证这份数据的正确性和一致性。
- 线程不安全则表示在多线程环境下，对于同一份数据，多个线程同时访问时可能会导致数据混乱、错误或者丢失。

导致线程不安全问题主要原因是：**指令交错**和**线程上下文切换**。

- 一个程序运行多个线程本身是没有问题的，问题出在多个线程访问共享资源。
- 多个线程读共享资源其实也没有问题，在多个线程对共享资源读写操作时发生指令交错，就会出现问题。
- 而指令交错的产生原因来自线程的上下文切换

因此并发编程容易产生线程安全问题，常见的解决思路有：

- 使用锁
- 无锁

---

## wait() VS sleep()

- 从 api 角度来看，sleep 是 Thread 方法，而 wait 是 Object 的方法
- sleep 不需要强制和 synchronized 配合使用，但 wait 需要和 synchronized 一起用
- sleep 在睡眠的同时，不会释放对象锁（这个时候其他线程来获取锁对象就需要去 entryList 中等待锁的释放），但 wait 在等待的时候会释放锁对象
- 进入的状态都是 TIMED_WAITING
- 它们都会释放 CPU 资源

---

## notify() VS notifyAll()

- `notify()`，用于唤醒一个正在等待相应对象锁的线程，使其进入就绪队列，以便在当前线程释放锁后竞争锁，进而得到 CPU 的执行。
- `notifyAll()`，用于唤醒所有正在等待相应对象锁的线程，使它们进入就绪队列，以便在当前线程释放锁后竞争锁，进而得到 CPU 的执行。

---

## 对 synchronized 关键字的理解

- synchronized 是 Java 中的关键字，它的作用是利用锁机制实现**线程的同步**。

- synchronized 可以修饰：实例方法、静态方法、代码块。

- 通过对同步的方法或代码块加锁，使得每次只能有一个线程进入同步块，从而保证线程的安全性。

- synchronized 还可以保证线程间的**可见性和有序性**。

- synchronized 底层是通过 monitor 机制实现的。Java 中每个对象都有一个 monitor，线程进入 synchronized 同步块中，需要先通过 monitorenter 指令获取到对象的 monitor 才能往下执行。执行结束后会通过 monitorexit 释放对象锁。

---

## TODO synchronized 关键字的底层原理

---

## 同步和异步

同步和异步通常用来形容一次**方法调用**：

- 同步（Synchronous）：方法调用在没有得到结果之前， 该调用就不可以返回，一直等待。
- 异步（Asynchronous）：方法调用在发出之后，不需要等待返回结果，该调用直接返回。

---

## 阻塞与非阻塞

阻塞和非阻塞通常用来形容**多线程之间的相互影响**：

- 阻塞（Blocking）：如果一个线程占用了临界区资源，那么其他所有需要这个资源的线程就必须等待；等待会导致线程挂起，这种情况就是阻塞。
- 非阻塞（Non-Blocking）：没有一个线程可以妨碍其他线程执行。

---

## 什么是临界区资源

临界区用来表示一种公共资源或共享数据，它可以被多个线程使用。但是每次只能有一个线程使用它，一旦临界区的资源被占用，其他线程要想使用这个资源就必须等待。e.g. 办公室只有一个打印机。

在并行程序中，临界区的资源是要被保护的对象。

---

## 原子性、可见性和有序性

- 原子性（Atomicity）：一个操作是不可中断的，即使在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰。

- 可见性（Visibility）：当一个线程修改了某个共享变量的值时，其他线程是否能够立即知道这个改动。可见性问题是一个综合性问题，通常与缓存优化，指令重排等有关。

- 有序性（Ordering）：指令重排可以保证串行语义一致，但是无法保证多线程的语义也一致。指令重排的出现与汇编指令的流水线技术有关，有了流水线技术，CPU 才能高效地执行，之所以需要做指令重排，是为了尽量减少中断流水线。

![](https://raw.githubusercontent.com/MXJULY/image/main/img/202309190622985.png)

---

## 线程的基本操作

- `interrupt()`
- `sleep()`, sleep 和 wait 的区别
- `join()`
- `yield()`

---

## 什么是 CAS？

CAS 是 "Compare and Swap" 的缩写，它是一种并发编程中用于实现无锁算法的机制，常配合 volatile 实现无锁并发。

CAS 操作通过比较内存中的值与期望值，如果相等则进行更新，否则不进行任何操作。**CAS 操作是原子性的，因此可以保证在多线程环境下的数据一致性。**

CAS 是一种乐观锁策略，它假定所有线程访问共享资源时不会发生冲突，因此不会阻塞其他线程。无锁操作是通过比较当前值和期望值是否相等实现的，如果不能，则说明该内存地址的值已经被其他线程修改过，不会进行更新。

CAS 能够避免传统锁机制所带来的线程阻塞和上下文切换开销，提供了更高的并发性能。

---

## CAS 的问题/缺点？

- ABA 问题（解决方案是加时间戳 AtomicStampedReference）
- 如果线程竞争激烈，自旋时间过长造成性能消耗
- 只能保证对一个共享变量的原子操作（解决方案是整合多个共享变量为一个）

---

## 对 volatile 关键字的理解

volatile 主要为了解决共享变量的可见性问题。 即每次对 volatile 变量的修改都会立刻被其他线程感知。

可见性问题主要是由于缓存优化和指令重排导致的。

实现原理：

- 写 volatile 变量在编译时添加 Lock 指令
  - 指令会将当前处理器缓存行中的数据写回主存
  - 并且让其他 CPU 里缓存了该内存地址的数据失效
- 通过强制要求线程从主存读取变量实现缓存一致性
- 针对指令重排，通过在特定位置插入内存屏障来防止处理器的重排序

---

## 为什么要使用线程池？

由于频繁地创建、销毁线程是很消耗系统资源的，因此大多数并发框架都会使用线程池来管理线程。

好处：

- **降低资源消耗**。通过复用已存在的线程和降低线程关闭的次数来尽可能降低系统性能损耗；

- **提升系统响应速度**。通过复用线程，省去创建线程的过程，因此整体上提升了系统的响应速度；

- **提高线程的可管理性**。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，因此，需要使用线程池来管理线程。

---

## 线程池的工作原理/任务执行流程？

1. 先判断线程池中核心线程池所有的线程是否都在执行任务。如果不是，则新创建一个线程执行刚提交的任务，否则，核心线程池中所有的线程都在执行任务，则进入第 2 步；

2. 判断当前阻塞队列是否已满，如果未满，则将提交的任务放置在阻塞队列中；否则，则进入第 3 步；

3. 判断线程池中所有的线程是否都在执行任务，如果没有，则创建一个新的线程来执行任务，否则，则交给饱和策略进行处理

![](https://raw.githubusercontent.com/MXJULY/image/main/img/202309190625324.png)

---

## 线程池的创建（各个参数的意义）

创建线程池主要是 ThreadPoolExecutor 类来完成，也可以使用 `java.util.concurrent.Executors`  类提供的工厂方法来创建线程池。

ThreadPoolExecutor 的有许多重载的构造方法，通过参数最多的构造方法来理解创建线程池有哪些需要配置的参数。

ThreadPoolExecutor 的构造方法为：

```java
ThreadPoolExecutor(int corePoolSize,
                   int maximumPoolSize,
                   long keepAliveTime,
                   TimeUnit unit,
                   BlockingQueue<Runnable> workQueue,
                   RejectedExecutionHandler handler,
                   ThreadFactory threadFactory)
```

1. corePoolSize：表示核心线程池的大小。
2. maximumPoolSize：表示线程池能创建线程的最大个数。
3. keepAliveTime：空闲线程存活时间。
4. unit：时间单位。为 keepAliveTime 指定时间单位。
5. workQueue：用于保存任务的阻塞队列。
6. threadFactory：创建线程的工厂类。可以通过指定线程工厂为每个创建出来的线程设置更有意义的名字。
7. handler：饱和策略。

饱和策略：

- AbortPolicy： 直接拒绝所提交的任务
- CallerRunsPolicy：只用调用者所在的线程来执行任务
- DiscardPolicy：不处理直接丢弃掉任务
- DiscardOldestPolicy：丢弃掉阻塞队列中存放时间最久的任务，执行当前任务

---

## 如何向线程池提交任务？

可以使用 `execute()` 和 `submit()` 方法：

- `execute()` 方法用于提交不需要返回值的任务
- `submit()` 方法用于提交需要返回值的任务，会返回一个 future 类型的对象，可以通过 `get()` 方法获得返回值

---

## 如何关闭线程池？

可以调用线程池的 `shutdown()` 或 `shutdownNow()` 方法来关闭线程池。

它们的原理是遍历线程池中的工作线程，逐个调用线程的 `interrupt()` 方法来中断线程。因此，无法响应中断的任务可能永远无法终止。

- `shutdownNow()` 首先将线程池的状态设置为 STOP，然后尝试停止所有的正在执行和未执行任务的线程，并返回等待执行任务的列表
- `shutdown()` 只是将线程池的状态设置为 SHUTDOWN 状态，然后中断所有没有正在执行任务的线程
