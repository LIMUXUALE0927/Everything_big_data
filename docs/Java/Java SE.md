## Java 编程语言有什么特点？

- 面向对象（体现了封装、继承、多态的特性）
- 跨平台（Java 程序是运行在虚拟机上的）
- 解释和编译共存
- 提供多线程支持

---

## 标识符和关键字的区别是什么？

标识符是我们编程时为变量、方法、类等取的名字，而在 Java 中有许多标识符被赋予了特殊的含义，这就是关键字。

常见的关键字有：`class, private, public, protected, import, extends, final, static, try, catch` 等

---

## 讲一下 `final, static, this, super` 关键字

`final` 可用于修饰变量、方法和类：

- 修饰变量时，如果修饰基本数据类型，表示一旦初始化其值无法修改；修饰引用类型时，表示初始化后不能指向其他对象。
- 修饰方法时，表示该方法不能被重写。
- 修饰类时，表示该类不能被继承。

`static` 可用于修饰成员变量、成员方法和代码块：

- 修饰成员变量和方法表示该变量和方法属于类，建议使用类名进行调用。
- 修饰代码块时表示该代码块是静态代码块，放在方法外，在类初始化时被调用。

`this` 用于指代当前对象，用于调用当前对象的变量或方法。
`super` 用于调用父类的变量和方法。

---

## Java 访问权限修饰符

Java 中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限。

- default: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。
- private: 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类）
- public: 对所有类可见。使用对象：类、接口、变量、方法
- protected: 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）。

---

## 重载和重写的区别？

重载是**创建具有相同名称但参数列表不同的方法**，目的是让方法调用根据参数类型和数量来执行不同的操作。

重写是**子类对父类方法进行覆盖，方法名称、参数列表和返回类型必须相同**，实现的目的是修改或扩展父类方法的行为。

重载的要求：

- 方法名相同
- 方法参数列表必须不同（类型、个数、顺序至少一个不同

重写的要求：

- 方法名和参数列表必须相同
- 重写方法不能使用比父类方法更严格的访问修饰符。例如，如果父类方法是 protected，子类方法不能是 private
- 子类中的重写方法不能抛出比父类方法更宽泛的异常，但可以抛出相同的异常或者不抛出异常

重载是**编译时静态绑定**的，根据方法调用时传递的参数类型和数量来确定调用哪个方法。重写是**运行时动态绑定**的，根据对象的实际类型来确定调用哪个方法。

---

## 什么是自动装箱与拆箱？

自动装箱：将基本数据类型自动转换为对应的包装类对象。

自动拆箱：将包装类对象自动转换为对应的基本数据类型。

> 为什么有基本数据类型还需要包装类型？

基本数据类型更节省内存，可以存储在栈中，而包装类型需要存储在堆中

使用包装类可以使基本数据类型有对象的属性和功能，让我们像使用对象一样使用基本数据类型

---

## 面向对象和面向过程的区别？

**面向过程以步骤来划分问题，面向对象是以功能模块来划分问题**，而不是步骤。

如五子棋，面向过程的设计思路就是首先分析问题的步骤：

开始游戏，黑子先走，绘制画面，判断输赢，轮到白子，绘制画面，判断输赢，返回步骤 2，输出最后结果。

把上面每个步骤用不同的方法来实现。

面向对象的设计则是从另外的思路来解决问题

整个五子棋可以分为：

1. 黑白双方，这两方的行为是一模一样的，
2. 棋盘系统，负责绘制画面，
3. 规则系统，负责判定诸如犯规、输赢等。

第一类对象（玩家对象）负责接受用户输入，并告知第二类对象（棋盘对象）棋子布局的变化，棋盘对象接收到了棋子的变化就要负责在屏幕上面显示出这种变化，同时利用第三类对象（规则系统）来对棋局进行判定。

---

## 什么是类，什么是对象？

类是对象的模板，对象是类的实例。

- 类是一种用来描述对象特征（属性）和行为（方法）的模板或蓝图。
- 类是创建对象的基础，它定义了对象的结构和行为。
- 类可以看作是一种用户自定义的数据类型，它封装了数据（属性）和操作数据的方法（行为）。
- 对象是类的实例，它具体化了类的特征和行为。

---

## 面向对象的三大特征

!!! note "封装（Encapsulation）"

封装指的是将数据和操作数据的方法捆绑在一起，形成一个独立的单元。类可以看作是封装的实现方式。让我们以汽车为例来解释封装。

汽车是一个封装的对象。它有各种属性（数据），如引擎类型、车身颜色、最高速度等。它还有各种方法（行为），如启动引擎、加速、刹车等。这些属性和方法被封装在汽车类中，外部无法直接访问和修改这些属性，而是通过公共接口（方法）来与汽车进行交互。这样的封装确保了对汽车内部实现的隐藏，使得外部用户只需关注与汽车交互的接口，而不需要了解其具体实现细节。

!!! note "继承（Inheritance）"

继承是指一个类可以从另一个类继承属性和方法，从而扩展或修改其功能。继承通过建立类之间的层次结构来组织和共享代码。让我们以动物为例来解释继承。

假设有一个基类叫做"动物"，它定义了通用的属性和方法，比如"呼吸"、"移动"等。然后，派生类（子类）如"狗"、"猫"、"鸟"可以继承"动物"类，并在其基础上添加特定的属性和方法，比如"狗"类可能有"叫声"、"摇尾巴"的方法。继承允许子类继承父类的特性，并根据需要进行扩展和定制。这样可以避免重复编写相同的代码，提高代码的重用性和可维护性。

!!! note "多态（Polymorphism）"

多态是指同一种操作或方法可以在不同的对象上产生不同的结果。多态允许使用父类类型的变量来引用子类对象，以实现灵活而统一的代码。让我们以形状为例来解释多态。

假设有一个基类叫做"形状"，它有一个方法叫做"计算面积"。然后，派生类如"圆形"、"矩形"、"三角形"可以分别重写"计算面积"方法，以适应不同形状的计算逻辑。当我们有一个指向"形状"对象的引用时，可以根据实际的对象类型调用相应的方法，从而实现多态。这样的多态性使得我们可以编写通用的代码，而不需要针对每个具体的形状编写特定的处理逻辑。

---

## 抽象类和接口的区别？

抽象类和接口是 Java 中用于实现抽象和定义规范的两种机制。

抽象类主要表示「is-a」（是什么）的关系，接口主要表示「has-a」（有什么功能）的关系。

抽象类用于作为其他类的基类或模板。

接口提供了一种规范，让不相关的类可以通过实现相同的接口来实现一致的行为。

共性：

- 都可以声明抽象方法
- 都不可以被直接实例化

不同：

- 关系：类与抽象类之间是继承关系，类与接口之间是实现关系，接口与接口之间是多继承关系
- 构造器：抽象类有构造器，接口没有
- 成员变量：抽象类可以包含实例变量，而接口只能包含常量(public static final)
- 方法：从 Java 8 开始，接口可以包含默认方法（default method）。默认方法是在接口中提供的具体方法实现，可以在实现接口的类中直接使用或覆盖。

总结：
抽象类更适合于具有共享行为和状态的类层次结构，而接口更适合于定义规范和实现多态性。

---

## 深拷贝和浅拷贝

对于一个引用数据类型，浅拷贝只复制它的引用（地址），而深拷贝则是新建一个相同类型的对象并复制它的内容。

---

## == 和 equals() 的区别？

`==` 用于判断基本类型的值是否相等或引用类型的内存地址是否相等。

`equals()` 用于判断引用类型的值是否相等：

- 如果对象没有重写 `equals()` 方法，则比较的还是对象的内存地址
- 如果重写了 `equals()` 方法，则按照 `equals()` 方法的逻辑比较

---

## 如何重写 equals() 方法？

1. 判断两个对象的内存地址是否相等
2. 判断被比较的对象是否为空
3. 判断两个对象的运行时类是否相等
4. 判断类的成员是否相等

```java
public class MyClass {
    private int id;
    private String name;

    // 构造函数、其他方法等

    @Override
    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }

        if (!(obj instanceof MyClass)) {
            return false;
        }

        MyClass other = (MyClass) obj;
        return this.id == other.id && this.name.equals(other.name);
    }
}
```

---

## Java 是值传递还是引用传递？

Java 是值传递。

值传递和引用传递最大的区别就是参数传递的过程中有没有复制出一个副本，如果传递的是副本，则是值传递，否则是引用传递。

Java 中的参数传递是值传递，只不过对于 Java 对象的传递，传递的内容是对象的内存地址的副本。

---

## HashCode 的作用是什么？

- 用于快速查找和比较对象，减少对象比较的次数。
- 与 `equals()` 方法一起用于确保哈希表中的对象的正确性和一致性。
- 支持基于哈希表的数据结构，提高对象的存储和检索效率。

> 为什么要同时重写 `equals()` 和 `hashCode()`？

因为两个对象相等的严格定义是：对象的内容（equals）相同，并且 hashcode 相同。如果违反这个规定，在使用基于 hashcode 的数据结构时产生错误。比如往 HashSet 里放入重写了 `equals()` 方法的两个内容相同的对象，但是没有重写 `hashCode()`，会导致 set 里有 2 个元素。

---

## Java 中的 String 为什么是 final 的？

在 Java 中，String 类被设计为 final 类，这意味着它不能被继承。这是出于安全性和不可变性的考虑而做出的决策。

安全性：如果 String 类可以被继承，子类可能会改变其中的行为，导致字符串的不可预测性和安全性问题。通过将 String 类声明为 final，Java 可以保证字符串对象的操作和语义在整个应用程序中是可靠和一致的。

不可变性：由于 String 是不可变的，可以将其安全地用作方法参数、缓存键等。不可变性还使得字符串在并发环境中更加安全，因为不需要同步来保证多个线程之间的一致性。如果 String 类可以被继承并修改其状态，那么可能会破坏不可变性的特性，带来潜在的问题。

---

## Java 中的异常有哪些？

Java 中的异常都来自于 `java.lang.Throwable` 类， 主要有 2 种：

- Error：程序无法处理的错误（虚拟机错误、OOM 等）
- Exception：程序可以处理的错误
  - 受检异常：编译器要求处理的异常（如 IOException）
  - 非受检异常：编译器不强制要求处理的异常（如数组越界）

处理异常的方法：

- try-catch 块：用于捕获和处理异常。try 代码块中包含可能会抛出异常的代码，catch 块用于捕获并处理特定类型的异常。
- `throws` 关键字：用于在方法签名中声明该方法可能抛出的异常，将异常传递给调用者处理。
- `throw` 关键字：用于在代码中抛出特定的异常。

---

## Java 中的泛型

泛型，是程序设计语言的一种风格。强类型语言支持泛型，其主要目的是**加强类型安全**和**减少类型转换的次数**。泛型最大的好处是可以**提高代码的复用性**。

以 List 接口为例，我们只需要使用泛型，就可以定义存储 String、Integer 等类型的 List，而不必实现多种 List。

泛型通常用在类、方法和接口上：

1. 泛型类（Generic Class）：可以在类的定义中使用泛型类型参数来表示类中的某些成员的类型。例如，`List<T>` 是一个泛型类，其中的 T 是类型参数，可以在实例化时指定具体的类型。
2. 泛型接口（Generic Interface）：与泛型类类似，可以在接口的定义中使用泛型类型参数。例如，`Comparable<T>` 是一个泛型接口，用于定义可比较的对象。
3. 泛型方法（Generic Method）：在方法的定义中使用泛型类型参数，使得方法可以接受不同类型的参数。例如，`<T> void printArray(T[] array)` 是一个泛型方法，可以打印任意类型的数组。

> 泛型可能会带来哪些问题？

- 由于类型擦除的原因，泛型经过编译之后会被编译器擦除，因此泛型会影响重载。
- 泛型不支持基本数据类型

---

## Java 中的反射

在 Java 中，反射（Reflection）是指在运行时动态地获取类的信息并操作类或对象的能力。通过反射，可以在运行时检查类、调用类的方法、访问类的字段以及创建新的对象实例。

---

## Comparable VS Comparator

在 Java 中，Comparable 和 Comparator 是用于比较对象的接口，但它们有一些区别。

Comparable 接口是在对象自身内部实现的，用于定义**对象的自然排序顺序**。它提供了一个 `compareTo()` 方法，该方法用于将对象与其他对象进行比较，并返回一个表示对象顺序关系的整数值。

Comparable 接口只能定义一种排序方式，因此每个类只能有一个默认的自然排序顺序。

Comparator 接口是在独立的比较器类中实现的，用于定义对象之间的自定义排序顺序。它提供了一个 `compare()` 方法，该方法接受两个对象作为参数，并返回一个表示对象顺序关系的整数值。

Comparator 接口可以用于对已有的类进行排序，而无需修改原始类的代码。

---

## Java IO

在 Java 中，IO 流（Input/Output streams）是用于处理输入和输出数据的机制。它提供了一种灵活的方式来读取和写入不同类型的数据，无论是从文件、网络连接还是其他来源。

- 根据流向，IO 流可分为输入流和输出流。
- 根据传输的单位，IO 流分为两类：字节流（Byte Streams）和字符流（Character Streams）。
- 根据流的角色，IO 流可分为节点流和处理流。

字节流主要用于处理二进制数据，将数据以字节为单位进行读取和写入。在字节流中，最基本的类是 InputStream 和 OutputStream。常见的字节流类包括 FileInputStream、FileOutputStream、ByteArrayInputStream 和 ByteArrayOutputStream。

字符流主要用于处理文本数据，将数据以字符为单位进行读取和写入。在字符流中，最基本的类是 Reader 和 Writer。常见的字符流类包括 FileReader、FileWriter、BufferedReader 和 BufferedWriter。

此外，Java 还提供了处理对象序列化的对象流（Object Streams）。对象流可以将 Java 对象转换为字节流进行持久化存储或网络传输，以及将字节流还原为 Java 对象。常见的对象流类有 ObjectInputStream 和 ObjectOutputStream。

为了提高 IO 操作的效率，Java 还提供了缓冲流（Buffered Streams）。缓冲流通过在内存中创建缓冲区，减少了对底层资源的直接访问次数，从而提高读写的性能。常见的缓冲流类有 BufferedInputStream、BufferedOutputStream、BufferedReader 和 BufferedWriter。

---

## 解释一下同步/异步与阻塞/非阻塞

当 IO 操作发生时，一定有调用方和被调用方两方的参与。阻塞与非阻塞描述的是调用方，同步与异步描述的是被调用方。

例如，A 调用 B：

- 如果是阻塞，那么 A 在发出调用命令后，要一直等待 B 返回结果
- 如果是非阻塞，那么 A 在发出调用命令后，不需要等待，可以去做自己的事情
- 如果是同步，那么 B 在收到 A 的调用命令后，会立即执行要做的事，A 的本次调用可以得到结果
- 如果是异步，那么 B 在收到 A 的调用命令后，不保证会立即执行要做的事，但是保证会做，B 在做好了之后会通知 A。A 的本次调用得不到结果，但是 B 执行完要做的事之后会通知 A

因为同步/异步与阻塞/非阻塞描述的对象不同，因此二者之间是没有必然的联系的。也就是说，同步不一定阻塞，异步也不一定非阻塞。

---

## Java 序列化与反序列化

在 Java 中，序列化（Serialization）是指将对象转换为字节流的过程，以便将其存储在文件中、通过网络发送或在内存中进行持久化。反序列化（Deserialization）则是将字节流转换回对象的过程。

Java 提供了内置的序列化机制，将对象的状态保存为字节数组，使得对象的序列化和反序列化变得简单。要使一个类可序列化，需要满足以下条件：

1. 实现 `java.io.Serializable` 接口：该接口是一个标记接口，没有定义任何方法。通过实现该接口，表明该类的实例可以被序列化。
2. 所有非瞬态（non-transient）的实例变量都可以被序列化：瞬态变量是通过 `transient` 关键字进行修饰的变量，不会被序列化。
3. 在类中增加 `writeObject()` 和 `readObject()` 方法可以实现自定义的序列化策略

---

## Linux 五大 IO 模型

[看一遍就理解：IO 模型详解](https://www.51cto.com/article/693213.html)

Java 中提供的 IO 有关的 API，其实是依赖操作系统层面的 IO 操作实现的。Java 中的 BIO、NIO 和 AIO 都是 Java 语言对操作系统的各种 IO 模型的封装。在 Linux 操作系统中，一共有 5 种 IO 模型：阻塞 IO、非阻塞 IO、IO 多路复用、信号驱动 IO 和异步 IO。

1. **阻塞 I/O（Blocking I/O）**：阻塞 I/O 是最简单的 I/O 模型之一。在阻塞 I/O 中，当应用程序进行 I/O 操作时，它会一直阻塞（即停止执行）直到操作完成。这意味着应用程序无法执行其他任务，直到 I/O 操作完成。这种模型实现简单，但是适合并发低，时效性要求低的场景。

2. **非阻塞 I/O（Non-blocking I/O）**：非阻塞 I/O 模型允许应用程序在进行 I/O 操作时继续执行其他任务，而不需要等待操作完成。如果 I/O 操作不能立即完成，应用程序可以立即返回并继续执行其他任务。应用程序可以通过轮询，周期性地检查 I/O 操作的状态，并根据需要重试。

3. **I/O 多路复用（I/O Multiplexing）**：I/O 多路复用是一种高效的 I/O 模型，它允许应用程序同时监视多个 I/O 事件，如套接字（socket）或文件描述符（file descriptor）。通过使用诸如 select、poll 或 epoll 等系统调用，应用程序可以等待多个 I/O 事件中的任何一个就绪，然后进行相应的处理。这种模型避免了阻塞和轮询的开销，提供了更高的并发性。 IO 多路复用是多了一个 select 函数，多个进程的 I/O 可以注册到同一个 select 上，当用户进程调用该 select 的时候，select 会监听所有注册好的 I/O，如果所有被监听的 I/O 都没准备好，那么 select 调用进程会阻塞。这里并没有向内核注册信号处理函数，因此 I/O 多路复用模型并不是非阻塞的。

4. **信号驱动 I/O（Signal-driven I/O）**：信号驱动 I/O 使用信号通知应用程序 I/O 操作的完成。应用程序向内核注册一个信号处理函数，并在发起 I/O 操作后继续执行其他任务。当 I/O 操作完成时，系统会发送一个信号给应用程序，触发相应的信号处理函数来处理完成的 I/O。基于信号驱动 IO 模型，内核是在数据准备好之后通知进程的，然后进程再通过 recvfrom 操作进行数据复制。我们可以认为数据准备阶段是异步的，但数据复制操作是同步的。

5. **异步 I/O（Asynchronous I/O）**：异步 I/O 是最高级别的 I/O 模型。在异步 I/O 中，应用程序发起一个 I/O 操作，并立即返回，而无需等待操作完成，完全由内核去完成操作。当操作完成时，应用程序会收到通知。相比于其他模型，异步 I/O 更适合于处理大量并发的 I/O 操作，因为它允许应用程序在等待 I/O 完成时处理其他任务，而不需要阻塞或轮询。

---

## 介绍下 Maven

Maven 是一个用于构建和管理 Java 项目的强大工具。它提供了一个标准化的项目结构、构建生命周期和依赖管理系统，使得项目的构建、测试、打包和部署等任务变得简单和可重复。

以下是关于 Maven 的一些重要概念和功能：

1. 项目对象模型（Project Object Model，POM）：Maven 使用 POM 文件来描述项目的配置信息和依赖关系。POM 文件是一个 XML 文件，定义了项目的坐标（groupId、artifactId、version）、构建设置、依赖项、插件等。

2. 坐标（Coordinates）：Maven 使用坐标来唯一标识项目。坐标包括 groupId、artifactId 和 version。groupId 表示项目所属的组织或团队，artifactId 表示项目的名称，version 表示项目的版本号。

3. 依赖管理（Dependency Management）：Maven 提供了强大的依赖管理系统，可以自动下载和管理项目所需的依赖项。通过在 POM 文件中声明依赖关系，Maven 可以自动解析和下载依赖项，并构建正确的依赖关系树。

4. 构建生命周期（Build Lifecycle）：Maven 定义了一组标准的构建生命周期，包括清理、编译、测试、打包、部署等阶段。每个生命周期由一系列阶段（Phases）组成，开发人员可以根据需要执行不同的生命周期阶段，以完成特定的构建任务。

5. 插件（Plugins）：Maven 插件是用于扩展 Maven 的功能的工具。插件可以用于执行各种任务，如编译代码、运行测试、生成文档、打包应用程序等。Maven 提供了一些常用插件，同时也支持自定义插件。

6. 仓库（Repository）：Maven 通过仓库来管理依赖项的存储和共享。Maven 有本地仓库和远程仓库两种类型。本地仓库位于开发者的本地计算机上，用于存储本地构建的依赖项。远程仓库是分布式的，用于存储和共享依赖项，开发者可以从远程仓库下载所需的依赖项。

Maven 的优势在于它提供了一种约定优于配置的方式来管理项目，简化了构建过程，提高了项目的可维护性和可重复性。它广泛应用于 Java 生态系统中，被许多开发团队和开源项目所采用。通过 Maven，开发者可以更专注于业务逻辑的开发，而不必花费过多精力在构建和依赖管理上。
