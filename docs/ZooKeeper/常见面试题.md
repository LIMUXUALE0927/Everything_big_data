## 集群和分布式的概念

!!! note " 集群 "

	利用多台廉价、普通的机器完成单个计算机无法完成的存储、计算任务，是对机器存储、计算能力的水平方向的扩展。（垂直方向的扩展指的是提高单台机器的存储、计算能力）

!!! note " 分布式 "

	集群常用于构建分布式系统，分布式系统的设计目标是将任务分解为多个子任务，并将这些子任务分配给不同的节点并行执行，从而提高计算的效率和可靠性。

## ZooKeeper 是什么

ZooKeeper 是一个分布式协调框架，主要用于解决分布式系统的一致性问题。

通过 ZooKeeper 可以方便地实现数据订阅/发布、分布式锁、Master 选举、负载均衡等功能。

## ZooKeeper 如何实现分布式协调服务

> 文件系统 + 注册监听机制

- ZooKeeper 维护一个类似于 Unix 文件系统的树形层次结构，每个节点叫一个 `znode`，它既可以是目录，也可以存放少量数据
- ZooKeeper 提供了注册监听机制，用于实现分布式系统中的事件通知和协调功能

## ZooKeeper 有哪些特点

- 顺序一致性：从同一个客户端发起的事务请求，最终会严格地按照发起顺序被应用到 ZooKeeper 中去
- 原子性：所有事务请求的处理结果在整个集群中所有机器上的应用情况是一致的（只能成功/失败，没有中间状态）
- 单一视图：无论客户端连接的是哪个 ZooKeeper 服务器，看到的服务器数据模型都是一致的


## ZooKeeper 的数据模型/简版文件系统

ZooKeeper 维护一个类似于 Unix 文件系统的树形层次结构，每个节点叫一个 `znode`，它既可以是目录，也可以存放少量数据。

ZooKeeper 中的 `znode` 有 4 种：

- `PERSISTENT`
- `PERSISTENT_SEQUENTIAL`
- `EPHEMERAL`
- `EPHEMERAL_SEQUENTIAL`

持久节点和临时节点的区别是：持久节点创建后在客户端断开连接后不会被删除，而临时节点创建后在客户端断开连接后会被自动删除。

顺序节点指的是 ZooKeeper 会自动为创建的节点名称后加上数字编号，维持其创建时的顺序。

> ZooKeeper 为什么设置临时节点和临时有序节点？

- 临时节点的生命周期与创建它的客户端会话相关联，当客户端断开连接时，临时节点会被自动删除。而顺序节点可以通过编号来确定其节点的创建顺序。这两个特点可以用来实现一些分布式的特性。

- 设计临时节点可以方便地实现分布式锁中独占锁的机制。同时有来自多个客户端的事务请求，ZooKeeper 要求多个客户端同时创建相同的节点，而 ZK 不允许节点重名，导致只有一个客户端，即最终创建好节点的那个客户端就相当于获取到了这把锁。同时临时节点能保证客户端断开连接时节点会自动被删除，就相当于释放了锁。

- 设计临时有序节点主要是为了保证事务的有序性。多个客户端通过在某个节点下创建临时有序节点，ZooKeeper 每次让序号最小的节点获取锁，这样可以保证事务的全局时序。

## ZooKeeper 的注册监听机制

客户端注册监听它关心的 `znode` 节点，当节点状态发生变化（`NodeCreated`, `NodeDeleted`, `NodeDataChanged`, `NodeChildChanged`）时，ZooKeeper 会主动通知客户端。

常见的 2 种通知机制模式：

- Pull 模式：客户端主动从服务端拉取最新的状态，这种方式需要客户端不断地通过轮询的方式获取服务端最新的状态
- Push 模式：服务端主动向客户端推送最新的状态，相比于 pull 模式，push 模式能够保证客户端数据的实时性，同时避免轮询的开销。

> 具体是如何实现的？/ Watcher

ZooKeeper 的注册监听机制是通过向 ZooKeeper 服务器发送请求时附加一个 Watcher 对象来实现的。当节点的状态发生变化时，ZooKeeper 会通知与该节点关联的 Watcher，从而触发相应的事件处理。

以下是在 ZooKeeper 中注册 Watcher 的步骤：

1. 创建 ZooKeeper 连接：首先，创建与 ZooKeeper 服务器的连接。

2. 注册 Watcher：一旦与 ZooKeeper 服务器建立连接，可以使用 `exists()`, `getData()`, `getChildren()` 等方法来创建节点或获取节点数据，并在这些方法的参数中传递一个 Watcher 对象。这样，当节点的状态发生变化时，ZooKeeper 服务器会发送通知给该节点上注册的 Watcher。

3. 处理 Watcher 事件：在 Watcher 对象中，实现 `process()` 方法来处理 Watcher 事件。当节点的状态发生变化时，ZooKeeper 服务器会调用注册的 Watcher 的 `process()` 方法，并传递相应的事件类型（例如节点创建、数据更新、节点删除等）。

4. 重新注册 Watcher：一旦 Watcher 事件被触发并处理完毕，可以选择重新注册 Watcher 来继续监听节点的变化。这可以通过在 `process()` 方法中再次调用相应的节点操作方法并传递相同的 Watcher 对象来实现。

需要注意的是，ZooKeeper 中的 Watcher 是一次性的，即在节点状态变化后，Watcher 只会触发一次，并且必须在每次事件触发后重新注册才能继续监听。因此，如果要持续监听节点状态的变化，需要在每次处理 Watcher 事件后重新注册 Watcher。

## ZooKeeper 集群的架构/角色

ZooKeeper 是经典的主从架构：

Leader：

- 处理事务请求（写操作）：Leader 负责处理所有的写操作请求，包括创建、更新和删除节点等。当客户端发送写请求时，Leader 接受请求并将其转化为事务，然后将事务广播给 Followers。
- 保持集群状态一致：Leader 负责保持集群的状态一致性。它通过内部的一致性协议（如 ZAB 协议）来确保写操作的顺序一致性和线性化。

Follower：

- 提供读操作服务：Follower 主要提供读操作服务。当客户端发送读取请求时，Follower 可以直接返回数据，而不需要进行复杂的一致性协议。
- 参与选举过程：如果当前的 Leader 失败，Follower 可以参与新的 Leader 选举过程。

Observer：

- 职责与 Follower 相同，主要是为了减轻集群读的负载压力，但不参与选举过程。

## ZooKeeper 的读写流程

读流程：

- 客户端先与某个 ZooKeeper 服务器建立 Session
- 直接从该服务器读取数据，返回客户端即可（ZooKeeper 的单一视图特点）
- 关闭 Session

写流程：

- 客户端与一个服务器 node1 建立 Session，通常是 follower
- 客户端向 ZK 集群写入数据，如 `create /test`
- follower 将写请求转发给 leader
- leader 收到请求后，将写请求转换成一个事务 proposal, 并将 proposal 广播给集群中所有的 follower
- 超过半数的 follower 节点同意 proposal，则 leader 提交 commit proposal，leader 本地创建 `/test` znode
- leader 通知所有 follower，也 commit proposal， follower 各自在本地创建 `/test`
- node1 响应客户端


## ZooKeeper 的 Leader 选举

ZooKeeper 在什么时候会进行 Leader 选举？

- 集群启动时
- 运行中 Leader 崩溃时

从 3.4.0 版本开始，只保留了 **TCP 版本的 FastLeaderElection**。

### 集群启动时的 Leader 选举

 **步骤一：每个 Server 会发出一个投票**

初始情况，每个节点都会将自己作为 Leader 来进行投票。每次投票包含的最基本的元素包括：所推举的服务器的 `myid` 和 `ZXID` ，以 `(myid, ZXID)` 的形式表示。

**步骤二：接收来自各个服务器的投票**

每个服务器都会接收来自其他服务器的投票，判断该投票的有效性，包括是否是本轮投票，是否来自 LOOKING 状态的服务器。

**步骤三：处理投票**

接收到投票后，需要将别人的投票和自己的投票进行比较。

- 优先检查 `ZXID` ，`ZXID` 较大的服务器优先作为 Leader（因为 ZXID 越大，数据越新，越能够保证数据的恢复）
- 如果 `ZXID` 相同，那么 `myid` 较大的服务器作为 Leader

重新将更新后的投票发出去。

**步骤四：统计投票**

每次投票后，服务器都会统计所有投票，判断是否已经有过半的机器接收到相同的投票信息。

**步骤五：改变服务器状态**

一旦确定了 Leader，每个服务器更新自己的状态：如果是 Follower 就变更为 FOLLOWING，如果是 Leader 就变更为 LEADING。

### 运行中 Leader 崩溃时的选举

- 状态变更。Leader 故障后，余下的非 Observer 服务器都会将自己的服务器状态变更为 LOOKING，然后开始进入 Leader 选举过程。

- 每个 Server 会发出投票。

- 接收来自各个服务器的投票，如果其他服务器的数据比自己的新会改投票。

- 处理和统计投票，每一轮投票结束后都会统计投票，超过半数即可当选。

- 改变服务器的状态，宣布当选。

![](https://raw.githubusercontent.com/MXJULY/image/main/img/202309141915598.png)
